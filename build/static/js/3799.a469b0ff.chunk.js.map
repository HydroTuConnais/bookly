{"version":3,"file":"static/js/3799.a469b0ff.chunk.js","mappings":"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","sources":["../node_modules/hast-util-from-dom/lib/index.js","../node_modules/hast-util-parse-selector/lib/index.js","../node_modules/hastscript/lib/core.js","../node_modules/hastscript/lib/html.js","../node_modules/hastscript/lib/svg-case-sensitive-tag-names.js","../node_modules/hastscript/lib/svg.js","../node_modules/web-namespaces/index.js"],"sourcesContent":["/**\n * @typedef {import('hast').Root} HastRoot\n * @typedef {import('hast').DocType} HastDoctype\n * @typedef {import('hast').Element} HastElement\n * @typedef {import('hast').Text} HastText\n * @typedef {import('hast').Comment} HastComment\n * @typedef {import('hast').Content} HastContent\n */\n\n/**\n * @typedef {HastContent | HastRoot} HastNode\n *\n * @callback AfterTransform\n *   Callback called when each node is transformed.\n * @param {Node} domNode\n *   DOM node that was handled.\n * @param {HastNode} hastNode\n *   Corresponding hast node.\n * @returns {void}\n *   Nothing.\n *\n * @typedef Options\n *   Configuration.\n * @property {AfterTransform | null | undefined} [afterTransform]\n *   Callback called when each node is transformed.\n */\n\nimport {webNamespaces} from 'web-namespaces'\nimport {h, s} from 'hastscript'\n\n/**\n * Transform a DOM tree to a hast tree.\n *\n * @param {Node} tree\n *   DOM tree to transform.\n * @param {Options | null | undefined} [options]\n *   Configuration (optional).\n * @returns {HastNode}\n *   Equivalent hast node.\n */\nexport function fromDom(tree, options) {\n  const result = tree ? transform(tree, options || {}) : undefined\n  return result || {type: 'root', children: []}\n}\n\n/**\n * @param {Node} node\n *   DOM node to transform.\n * @param {Options} options\n *   Configuration.\n * @returns {HastNode | undefined}\n *   Equivalent hast node.\n *\n *   Note that certain legacy DOM nodes (i.e., Attr nodes (2),  CDATA, processing instructions)\n */\nfunction transform(node, options) {\n  const transformed = one(node, options)\n  if (transformed && options.afterTransform)\n    options.afterTransform(node, transformed)\n  return transformed\n}\n\n/**\n * @param {Node} node\n *   DOM node to transform.\n * @param {Options} options\n *   Configuration.\n * @returns {HastNode | undefined}\n *   Equivalent hast node.\n */\nfunction one(node, options) {\n  switch (node.nodeType) {\n    case 1 /* Element */: {\n      // @ts-expect-error TypeScript is wrong.\n      return element(node, options)\n    }\n\n    // Ignore: Attr (2).\n\n    case 3 /* Text */: {\n      // @ts-expect-error TypeScript is wrong.\n      return text(node)\n    }\n\n    // Ignore: CDATA (4).\n    // Removed: Entity reference (5)\n    // Removed: Entity (6)\n    // Ignore: Processing instruction (7).\n\n    case 8 /* Comment */: {\n      // @ts-expect-error TypeScript is wrong.\n      return comment(node)\n    }\n\n    case 9 /* Document */: {\n      // @ts-expect-error TypeScript is wrong.\n      return root(node, options)\n    }\n\n    case 10 /* Document type */: {\n      return doctype()\n    }\n\n    case 11 /* Document fragment */: {\n      // @ts-expect-error TypeScript is wrong.\n      return root(node, options)\n    }\n\n    default: {\n      return undefined\n    }\n  }\n}\n\n/**\n * Transform a document.\n *\n * @param {Document | DocumentFragment} node\n *   DOM node to transform.\n * @param {Options} options\n *   Configuration.\n * @returns {HastRoot}\n *   Equivalent hast node.\n */\nfunction root(node, options) {\n  return {type: 'root', children: all(node, options)}\n}\n\n/**\n * Transform a doctype.\n *\n * @returns {HastDoctype}\n *   Equivalent hast node.\n */\nfunction doctype() {\n  // @ts-expect-error hast types out of date.\n  return {type: 'doctype'}\n}\n\n/**\n * Transform a text.\n *\n * @param {Text} node\n *   DOM node to transform.\n * @returns {HastText}\n *   Equivalent hast node.\n */\nfunction text(node) {\n  return {type: 'text', value: node.nodeValue || ''}\n}\n\n/**\n * Transform a comment.\n *\n * @param {Comment} node\n *   DOM node to transform.\n * @returns {HastComment}\n *   Equivalent hast node.\n */\nfunction comment(node) {\n  return {type: 'comment', value: node.nodeValue || ''}\n}\n\n/**\n * Transform an element.\n *\n * @param {Element} node\n *   DOM node to transform.\n * @param {Options} options\n *   Configuration.\n * @returns {HastElement}\n *   Equivalent hast node.\n */\nfunction element(node, options) {\n  const space = node.namespaceURI\n  const fn = space === webNamespaces.svg ? s : h\n  const tagName =\n    space === webNamespaces.html ? node.tagName.toLowerCase() : node.tagName\n  /** @type {DocumentFragment | Element} */\n  const content =\n    // @ts-expect-error Types are wrong.\n    space === webNamespaces.html && tagName === 'template' ? node.content : node\n  const attributes = node.getAttributeNames()\n  /** @type {Record<string, string>} */\n  const props = {}\n  let index = -1\n\n  while (++index < attributes.length) {\n    props[attributes[index]] = node.getAttribute(attributes[index]) || ''\n  }\n\n  return fn(tagName, props, all(content, options))\n}\n\n/**\n * Transform child nodes in a parent.\n *\n * @param {Document | DocumentFragment | Element} node\n *   DOM node to transform.\n * @param {Options} options\n *   Configuration.\n * @returns {Array<HastContent>}\n *   Equivalent hast nodes.\n */\nfunction all(node, options) {\n  const nodes = node.childNodes\n  /** @type {Array<HastContent>} */\n  const children = []\n  let index = -1\n\n  while (++index < nodes.length) {\n    const child = transform(nodes[index], options)\n\n    if (child !== undefined) {\n      // @ts-expect-error Assume no document inside document.\n      children.push(child)\n    }\n  }\n\n  return children\n}\n","/**\n * @typedef {import('hast').Properties} Properties\n * @typedef {import('hast').Element} Element\n */\n\nconst search = /[#.]/g\n\n/**\n * Create a hast element from a simple CSS selector.\n *\n * @template {string} Selector\n *   Type of selector.\n * @template {string} [DefaultTagName='div']\n *   Type of default tag name.\n * @param {Selector | null | undefined} [selector]\n *   Simple CSS selector.\n *\n *   Can contain a tag name (`foo`), classes (`.bar`), and an ID (`#baz`).\n *   Multiple classes are allowed.\n *   Uses the last ID if multiple IDs are found.\n * @param {DefaultTagName | null | undefined} [defaultTagName='div']\n *   Tag name to use if `selector` does not specify one (default: `'div'`).\n * @returns {Element & {tagName: import('./extract.js').ExtractTagName<Selector, DefaultTagName>}}\n *   Built element.\n */\nexport function parseSelector(selector, defaultTagName) {\n  const value = selector || ''\n  /** @type {Properties} */\n  const props = {}\n  let start = 0\n  /** @type {string | undefined} */\n  let previous\n  /** @type {string | undefined} */\n  let tagName\n\n  while (start < value.length) {\n    search.lastIndex = start\n    const match = search.exec(value)\n    const subvalue = value.slice(start, match ? match.index : value.length)\n\n    if (subvalue) {\n      if (!previous) {\n        tagName = subvalue\n      } else if (previous === '#') {\n        props.id = subvalue\n      } else if (Array.isArray(props.className)) {\n        props.className.push(subvalue)\n      } else {\n        props.className = [subvalue]\n      }\n\n      start += subvalue.length\n    }\n\n    if (match) {\n      previous = match[0]\n      start++\n    }\n  }\n\n  return {\n    type: 'element',\n    // @ts-expect-error: fine.\n    tagName: tagName || defaultTagName || 'div',\n    properties: props,\n    children: []\n  }\n}\n","/**\n * @typedef {import('hast').Root} Root\n * @typedef {import('hast').Content} Content\n * @typedef {import('hast').Element} Element\n * @typedef {import('hast').Properties} Properties\n * @typedef {import('property-information').Info} Info\n * @typedef {import('property-information').Schema} Schema\n */\n\n/**\n * @typedef {Content | Root} Node\n *   Any concrete `hast` node.\n * @typedef {Root | Element} HResult\n *   Result from a `h` (or `s`) call.\n *\n * @typedef {string | number} HStyleValue\n *   Value for a CSS style field.\n * @typedef {Record<string, HStyleValue>} HStyle\n *   Supported value of a `style` prop.\n * @typedef {string | number | boolean | null | undefined} HPrimitiveValue\n *   Primitive property value.\n * @typedef {Array<string | number>} HArrayValue\n *   List of property values for space- or comma separated values (such as `className`).\n * @typedef {HPrimitiveValue | HArrayValue} HPropertyValue\n *   Primitive value or list value.\n * @typedef {{[property: string]: HPropertyValue | HStyle}} HProperties\n *   Acceptable value for element properties.\n *\n * @typedef {string | number | null | undefined} HPrimitiveChild\n *   Primitive children, either ignored (nullish), or turned into text nodes.\n * @typedef {Array<Node | HPrimitiveChild>} HArrayChild\n *   List of children.\n * @typedef {Node | HPrimitiveChild | HArrayChild} HChild\n *   Acceptable child value.\n */\n\nimport {find, normalize} from 'property-information'\nimport {parseSelector} from 'hast-util-parse-selector'\nimport {parse as spaces} from 'space-separated-tokens'\nimport {parse as commas} from 'comma-separated-tokens'\n\nconst buttonTypes = new Set(['menu', 'submit', 'reset', 'button'])\n\nconst own = {}.hasOwnProperty\n\n/**\n * @param {Schema} schema\n * @param {string} defaultTagName\n * @param {Array<string>} [caseSensitive]\n */\nexport function core(schema, defaultTagName, caseSensitive) {\n  const adjust = caseSensitive && createAdjustMap(caseSensitive)\n\n  const h =\n    /**\n     * @type {{\n     *   (): Root\n     *   (selector: null | undefined, ...children: Array<HChild>): Root\n     *   (selector: string, properties?: HProperties, ...children: Array<HChild>): Element\n     *   (selector: string, ...children: Array<HChild>): Element\n     * }}\n     */\n    (\n      /**\n       * Hyperscript compatible DSL for creating virtual hast trees.\n       *\n       * @param {string | null} [selector]\n       * @param {HProperties | HChild} [properties]\n       * @param {Array<HChild>} children\n       * @returns {HResult}\n       */\n      function (selector, properties, ...children) {\n        let index = -1\n        /** @type {HResult} */\n        let node\n\n        if (selector === undefined || selector === null) {\n          node = {type: 'root', children: []}\n          // @ts-expect-error Properties are not supported for roots.\n          children.unshift(properties)\n        } else {\n          node = parseSelector(selector, defaultTagName)\n          // Normalize the name.\n          node.tagName = node.tagName.toLowerCase()\n          if (adjust && own.call(adjust, node.tagName)) {\n            node.tagName = adjust[node.tagName]\n          }\n\n          // Handle props.\n          if (isProperties(properties, node.tagName)) {\n            /** @type {string} */\n            let key\n\n            for (key in properties) {\n              if (own.call(properties, key)) {\n                // @ts-expect-error `node.properties` is set.\n                addProperty(schema, node.properties, key, properties[key])\n              }\n            }\n          } else {\n            children.unshift(properties)\n          }\n        }\n\n        // Handle children.\n        while (++index < children.length) {\n          addChild(node.children, children[index])\n        }\n\n        if (node.type === 'element' && node.tagName === 'template') {\n          node.content = {type: 'root', children: node.children}\n          node.children = []\n        }\n\n        return node\n      }\n    )\n\n  return h\n}\n\n/**\n * @param {HProperties | HChild} value\n * @param {string} name\n * @returns {value is HProperties}\n */\nfunction isProperties(value, name) {\n  if (\n    value === null ||\n    value === undefined ||\n    typeof value !== 'object' ||\n    Array.isArray(value)\n  ) {\n    return false\n  }\n\n  if (name === 'input' || !value.type || typeof value.type !== 'string') {\n    return true\n  }\n\n  if ('children' in value && Array.isArray(value.children)) {\n    return false\n  }\n\n  if (name === 'button') {\n    return buttonTypes.has(value.type.toLowerCase())\n  }\n\n  return !('value' in value)\n}\n\n/**\n * @param {Schema} schema\n * @param {Properties} properties\n * @param {string} key\n * @param {HStyle | HPropertyValue} value\n * @returns {void}\n */\nfunction addProperty(schema, properties, key, value) {\n  const info = find(schema, key)\n  let index = -1\n  /** @type {HPropertyValue} */\n  let result\n\n  // Ignore nullish and NaN values.\n  if (value === undefined || value === null) return\n\n  if (typeof value === 'number') {\n    // Ignore NaN.\n    if (Number.isNaN(value)) return\n\n    result = value\n  }\n  // Booleans.\n  else if (typeof value === 'boolean') {\n    result = value\n  }\n  // Handle list values.\n  else if (typeof value === 'string') {\n    if (info.spaceSeparated) {\n      result = spaces(value)\n    } else if (info.commaSeparated) {\n      result = commas(value)\n    } else if (info.commaOrSpaceSeparated) {\n      result = spaces(commas(value).join(' '))\n    } else {\n      result = parsePrimitive(info, info.property, value)\n    }\n  } else if (Array.isArray(value)) {\n    result = value.concat()\n  } else {\n    result = info.property === 'style' ? style(value) : String(value)\n  }\n\n  if (Array.isArray(result)) {\n    /** @type {Array<string | number>} */\n    const finalResult = []\n\n    while (++index < result.length) {\n      // @ts-expect-error Assume no booleans in array.\n      finalResult[index] = parsePrimitive(info, info.property, result[index])\n    }\n\n    result = finalResult\n  }\n\n  // Class names (which can be added both on the `selector` and here).\n  if (info.property === 'className' && Array.isArray(properties.className)) {\n    // @ts-expect-error Assume no booleans in `className`.\n    result = properties.className.concat(result)\n  }\n\n  properties[info.property] = result\n}\n\n/**\n * @param {Array<Content>} nodes\n * @param {HChild} value\n * @returns {void}\n */\nfunction addChild(nodes, value) {\n  let index = -1\n\n  if (value === undefined || value === null) {\n    // Empty.\n  } else if (typeof value === 'string' || typeof value === 'number') {\n    nodes.push({type: 'text', value: String(value)})\n  } else if (Array.isArray(value)) {\n    while (++index < value.length) {\n      addChild(nodes, value[index])\n    }\n  } else if (typeof value === 'object' && 'type' in value) {\n    if (value.type === 'root') {\n      addChild(nodes, value.children)\n    } else {\n      nodes.push(value)\n    }\n  } else {\n    throw new Error('Expected node, nodes, or string, got `' + value + '`')\n  }\n}\n\n/**\n * Parse a single primitives.\n *\n * @param {Info} info\n * @param {string} name\n * @param {HPrimitiveValue} value\n * @returns {HPrimitiveValue}\n */\nfunction parsePrimitive(info, name, value) {\n  if (typeof value === 'string') {\n    if (info.number && value && !Number.isNaN(Number(value))) {\n      return Number(value)\n    }\n\n    if (\n      (info.boolean || info.overloadedBoolean) &&\n      (value === '' || normalize(value) === normalize(name))\n    ) {\n      return true\n    }\n  }\n\n  return value\n}\n\n/**\n * Serialize a `style` object as a string.\n *\n * @param {HStyle} value\n *   Style object.\n * @returns {string}\n *   CSS string.\n */\nfunction style(value) {\n  /** @type {Array<string>} */\n  const result = []\n  /** @type {string} */\n  let key\n\n  for (key in value) {\n    if (own.call(value, key)) {\n      result.push([key, value[key]].join(': '))\n    }\n  }\n\n  return result.join('; ')\n}\n\n/**\n * Create a map to adjust casing.\n *\n * @param {Array<string>} values\n *   List of properly cased keys.\n * @returns {Record<string, string>}\n *   Map of lowercase keys to uppercase keys.\n */\nfunction createAdjustMap(values) {\n  /** @type {Record<string, string>} */\n  const result = {}\n  let index = -1\n\n  while (++index < values.length) {\n    result[values[index].toLowerCase()] = values[index]\n  }\n\n  return result\n}\n","/**\n * @typedef {import('./core.js').HChild} Child\n *   Acceptable child value.\n * @typedef {import('./core.js').HProperties} Properties\n *   Acceptable value for element properties.\n * @typedef {import('./core.js').HResult} Result\n *   Result from a `h` (or `s`) call.\n *\n * @typedef {import('./jsx-classic.js').Element} h.JSX.Element\n * @typedef {import('./jsx-classic.js').IntrinsicAttributes} h.JSX.IntrinsicAttributes\n * @typedef {import('./jsx-classic.js').IntrinsicElements} h.JSX.IntrinsicElements\n * @typedef {import('./jsx-classic.js').ElementChildrenAttribute} h.JSX.ElementChildrenAttribute\n */\n\nimport {html} from 'property-information'\nimport {core} from './core.js'\n\nexport const h = core(html, 'div')\n","export const svgCaseSensitiveTagNames = [\n  'altGlyph',\n  'altGlyphDef',\n  'altGlyphItem',\n  'animateColor',\n  'animateMotion',\n  'animateTransform',\n  'clipPath',\n  'feBlend',\n  'feColorMatrix',\n  'feComponentTransfer',\n  'feComposite',\n  'feConvolveMatrix',\n  'feDiffuseLighting',\n  'feDisplacementMap',\n  'feDistantLight',\n  'feDropShadow',\n  'feFlood',\n  'feFuncA',\n  'feFuncB',\n  'feFuncG',\n  'feFuncR',\n  'feGaussianBlur',\n  'feImage',\n  'feMerge',\n  'feMergeNode',\n  'feMorphology',\n  'feOffset',\n  'fePointLight',\n  'feSpecularLighting',\n  'feSpotLight',\n  'feTile',\n  'feTurbulence',\n  'foreignObject',\n  'glyphRef',\n  'linearGradient',\n  'radialGradient',\n  'solidColor',\n  'textArea',\n  'textPath'\n]\n","/**\n * @typedef {import('./core.js').HChild} Child\n *   Acceptable child value.\n * @typedef {import('./core.js').HProperties} Properties\n *   Acceptable value for element properties.\n * @typedef {import('./core.js').HResult} Result\n *   Result from a `h` (or `s`) call.\n *\n * @typedef {import('./jsx-classic.js').Element} s.JSX.Element\n * @typedef {import('./jsx-classic.js').IntrinsicAttributes} s.JSX.IntrinsicAttributes\n * @typedef {import('./jsx-classic.js').IntrinsicElements} s.JSX.IntrinsicElements\n * @typedef {import('./jsx-classic.js').ElementChildrenAttribute} s.JSX.ElementChildrenAttribute\n */\n\nimport {svg} from 'property-information'\nimport {core} from './core.js'\nimport {svgCaseSensitiveTagNames} from './svg-case-sensitive-tag-names.js'\n\nexport const s = core(svg, 'g', svgCaseSensitiveTagNames)\n","/**\n * Map of web namespaces.\n *\n * @type {Record<string, string>}\n */\nexport const webNamespaces = {\n  html: 'http://www.w3.org/1999/xhtml',\n  mathml: 'http://www.w3.org/1998/Math/MathML',\n  svg: 'http://www.w3.org/2000/svg',\n  xlink: 'http://www.w3.org/1999/xlink',\n  xml: 'http://www.w3.org/XML/1998/namespace',\n  xmlns: 'http://www.w3.org/2000/xmlns/'\n}\n"],"names":["fromDom","tree","options","transform","undefined","type","children","node","transformed","nodeType","space","namespaceURI","fn","webNamespaces","svg","s","h","tagName","html","toLowerCase","content","attributes","getAttributeNames","props","index","length","getAttribute","all","element","value","nodeValue","text","comment","root","one","afterTransform","nodes","childNodes","child","push","search","buttonTypes","Set","own","hasOwnProperty","core","schema","defaultTagName","caseSensitive","adjust","values","result","createAdjustMap","selector","properties","_len","arguments","Array","_key","unshift","previous","start","lastIndex","match","exec","subvalue","slice","id","isArray","className","parseSelector","call","name","has","isProperties","key","addProperty","addChild","info","find","Number","isNaN","spaceSeparated","spaces","commaSeparated","commas","commaOrSpaceSeparated","join","parsePrimitive","property","concat","style","String","finalResult","Error","number","boolean","overloadedBoolean","normalize","mathml","xlink","xml","xmlns"],"sourceRoot":""}