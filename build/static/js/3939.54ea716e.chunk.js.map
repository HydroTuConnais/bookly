{"version":3,"file":"static/js/3939.54ea716e.chunk.js","mappings":"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","sources":["../node_modules/decode-named-character-reference/index.dom.js","../node_modules/mdast-util-phrasing/node_modules/unist-util-is/lib/index.js","../node_modules/mdast-util-phrasing/lib/index.js","../node_modules/mdast-util-to-markdown/lib/handle/inline-code.js","../node_modules/mdast-util-to-markdown/lib/handle/list-item.js","../node_modules/mdast-util-to-markdown/lib/util/check-list-item-indent.js","../node_modules/mdast-util-to-markdown/lib/util/association.js","../node_modules/mdast-util-to-markdown/lib/util/check-bullet.js","../node_modules/mdast-util-to-markdown/lib/util/container-flow.js","../node_modules/mdast-util-to-markdown/lib/util/container-phrasing.js","../node_modules/mdast-util-to-markdown/lib/util/indent-lines.js","../node_modules/mdast-util-to-markdown/lib/util/pattern-compile.js","../node_modules/mdast-util-to-markdown/lib/util/pattern-in-scope.js","../node_modules/mdast-util-to-markdown/lib/util/safe.js","../node_modules/mdast-util-to-markdown/lib/util/track.js","../node_modules/mdast-util-to-string/lib/index.js","../node_modules/micromark-util-decode-numeric-character-reference/index.js","../node_modules/micromark-util-decode-string/index.js","../node_modules/mdast-util-to-markdown/lib/configure.js","../node_modules/mdast-util-to-markdown/lib/handle/blockquote.js","../node_modules/mdast-util-to-markdown/lib/handle/break.js","../node_modules/mdast-util-to-markdown/lib/util/format-code-as-indented.js","../node_modules/mdast-util-to-markdown/lib/handle/code.js","../node_modules/mdast-util-to-markdown/lib/util/check-quote.js","../node_modules/mdast-util-to-markdown/lib/handle/emphasis.js","../node_modules/mdast-util-to-markdown/lib/util/check-emphasis.js","../node_modules/mdast-util-to-markdown/lib/util/format-heading-as-setext.js","../node_modules/mdast-util-to-markdown/lib/handle/html.js","../node_modules/mdast-util-to-markdown/lib/handle/image.js","../node_modules/mdast-util-to-markdown/lib/handle/image-reference.js","../node_modules/mdast-util-to-markdown/lib/util/format-link-as-autolink.js","../node_modules/mdast-util-to-markdown/lib/handle/link.js","../node_modules/mdast-util-to-markdown/lib/handle/link-reference.js","../node_modules/mdast-util-to-markdown/lib/util/check-bullet-ordered.js","../node_modules/mdast-util-to-markdown/lib/util/check-rule.js","../node_modules/mdast-util-to-markdown/lib/handle/strong.js","../node_modules/mdast-util-to-markdown/lib/util/check-strong.js","../node_modules/mdast-util-to-markdown/lib/handle/index.js","../node_modules/mdast-util-to-markdown/lib/util/check-fence.js","../node_modules/longest-streak/index.js","../node_modules/mdast-util-to-markdown/lib/handle/definition.js","../node_modules/mdast-util-to-markdown/lib/handle/heading.js","../node_modules/mdast-util-to-markdown/lib/handle/list.js","../node_modules/mdast-util-to-markdown/lib/util/check-bullet-ordered-other.js","../node_modules/mdast-util-to-markdown/lib/util/check-bullet-other.js","../node_modules/mdast-util-to-markdown/lib/handle/paragraph.js","../node_modules/mdast-util-to-markdown/lib/handle/root.js","../node_modules/mdast-util-to-markdown/lib/handle/text.js","../node_modules/mdast-util-to-markdown/lib/handle/thematic-break.js","../node_modules/mdast-util-to-markdown/lib/util/check-rule-repetition.js","../node_modules/mdast-util-to-markdown/lib/join.js","../node_modules/mdast-util-to-markdown/lib/unsafe.js","../node_modules/mdast-util-to-markdown/lib/index.js","../node_modules/remark-stringify/lib/index.js"],"sourcesContent":["/// <reference lib=\"dom\" />\n\n/* eslint-env browser */\n\nconst element = document.createElement('i')\n\n/**\n * @param {string} value\n * @returns {string|false}\n */\nexport function decodeNamedCharacterReference(value) {\n  const characterReference = '&' + value + ';'\n  element.innerHTML = characterReference\n  const char = element.textContent\n\n  // Some named character references do not require the closing semicolon\n  // (`&not`, for instance), which leads to situations where parsing the assumed\n  // named reference of `&notit;` will result in the string `¬it;`.\n  // When we encounter a trailing semicolon after parsing, and the character\n  // reference to decode was not a semicolon (`&semi;`), we can assume that the\n  // matching was not complete.\n  // @ts-expect-error: TypeScript is wrong that `textContent` on elements can\n  // yield `null`.\n  if (char.charCodeAt(char.length - 1) === 59 /* `;` */ && value !== 'semi') {\n    return false\n  }\n\n  // If the decoded string is equal to the input, the character reference was\n  // not valid.\n  // @ts-expect-error: TypeScript is wrong that `textContent` on elements can\n  // yield `null`.\n  return char === characterReference ? false : char\n}\n","/**\n * @typedef {import('unist').Node} Node\n * @typedef {import('unist').Parent} Parent\n */\n\n/**\n * @typedef {Record<string, unknown>} Props\n * @typedef {null | undefined | string | Props | TestFunctionAnything | Array<string | Props | TestFunctionAnything>} Test\n *   Check for an arbitrary node, unaware of TypeScript inferral.\n *\n * @callback TestFunctionAnything\n *   Check if a node passes a test, unaware of TypeScript inferral.\n * @param {unknown} this\n *   The given context.\n * @param {Node} node\n *   A node.\n * @param {number | null | undefined} [index]\n *   The node’s position in its parent.\n * @param {Parent | null | undefined} [parent]\n *   The node’s parent.\n * @returns {boolean | void}\n *   Whether this node passes the test.\n */\n\n/**\n * @template {Node} Kind\n *   Node type.\n * @typedef {Kind['type'] | Partial<Kind> | TestFunctionPredicate<Kind> | Array<Kind['type'] | Partial<Kind> | TestFunctionPredicate<Kind>>} PredicateTest\n *   Check for a node that can be inferred by TypeScript.\n */\n\n/**\n * Check if a node passes a certain test.\n *\n * @template {Node} Kind\n *   Node type.\n * @callback TestFunctionPredicate\n *   Complex test function for a node that can be inferred by TypeScript.\n * @param {Node} node\n *   A node.\n * @param {number | null | undefined} [index]\n *   The node’s position in its parent.\n * @param {Parent | null | undefined} [parent]\n *   The node’s parent.\n * @returns {node is Kind}\n *   Whether this node passes the test.\n */\n\n/**\n * @callback AssertAnything\n *   Check that an arbitrary value is a node, unaware of TypeScript inferral.\n * @param {unknown} [node]\n *   Anything (typically a node).\n * @param {number | null | undefined} [index]\n *   The node’s position in its parent.\n * @param {Parent | null | undefined} [parent]\n *   The node’s parent.\n * @returns {boolean}\n *   Whether this is a node and passes a test.\n */\n\n/**\n * Check if a node is a node and passes a certain node test.\n *\n * @template {Node} Kind\n *   Node type.\n * @callback AssertPredicate\n *   Check that an arbitrary value is a specific node, aware of TypeScript.\n * @param {unknown} [node]\n *   Anything (typically a node).\n * @param {number | null | undefined} [index]\n *   The node’s position in its parent.\n * @param {Parent | null | undefined} [parent]\n *   The node’s parent.\n * @returns {node is Kind}\n *   Whether this is a node and passes a test.\n */\n\n/**\n * Check if `node` is a `Node` and whether it passes the given test.\n *\n * @param node\n *   Thing to check, typically `Node`.\n * @param test\n *   A check for a specific node.\n * @param index\n *   The node’s position in its parent.\n * @param parent\n *   The node’s parent.\n * @returns\n *   Whether `node` is a node and passes a test.\n */\nexport const is =\n  /**\n   * @type {(\n   *   (() => false) &\n   *   (<Kind extends Node = Node>(node: unknown, test: PredicateTest<Kind>, index: number, parent: Parent, context?: unknown) => node is Kind) &\n   *   (<Kind extends Node = Node>(node: unknown, test: PredicateTest<Kind>, index?: null | undefined, parent?: null | undefined, context?: unknown) => node is Kind) &\n   *   ((node: unknown, test: Test, index: number, parent: Parent, context?: unknown) => boolean) &\n   *   ((node: unknown, test?: Test, index?: null | undefined, parent?: null | undefined, context?: unknown) => boolean)\n   * )}\n   */\n  (\n    /**\n     * @param {unknown} [node]\n     * @param {Test} [test]\n     * @param {number | null | undefined} [index]\n     * @param {Parent | null | undefined} [parent]\n     * @param {unknown} [context]\n     * @returns {boolean}\n     */\n    // eslint-disable-next-line max-params\n    function is(node, test, index, parent, context) {\n      const check = convert(test)\n\n      if (\n        index !== undefined &&\n        index !== null &&\n        (typeof index !== 'number' ||\n          index < 0 ||\n          index === Number.POSITIVE_INFINITY)\n      ) {\n        throw new Error('Expected positive finite index')\n      }\n\n      if (\n        parent !== undefined &&\n        parent !== null &&\n        (!is(parent) || !parent.children)\n      ) {\n        throw new Error('Expected parent node')\n      }\n\n      if (\n        (parent === undefined || parent === null) !==\n        (index === undefined || index === null)\n      ) {\n        throw new Error('Expected both parent and index')\n      }\n\n      // @ts-expect-error Looks like a node.\n      return node && node.type && typeof node.type === 'string'\n        ? Boolean(check.call(context, node, index, parent))\n        : false\n    }\n  )\n\n/**\n * Generate an assertion from a test.\n *\n * Useful if you’re going to test many nodes, for example when creating a\n * utility where something else passes a compatible test.\n *\n * The created function is a bit faster because it expects valid input only:\n * a `node`, `index`, and `parent`.\n *\n * @param test\n *   *   when nullish, checks if `node` is a `Node`.\n *   *   when `string`, works like passing `(node) => node.type === test`.\n *   *   when `function` checks if function passed the node is true.\n *   *   when `object`, checks that all keys in test are in node, and that they have (strictly) equal values.\n *   *   when `array`, checks if any one of the subtests pass.\n * @returns\n *   An assertion.\n */\nexport const convert =\n  /**\n   * @type {(\n   *   (<Kind extends Node>(test: PredicateTest<Kind>) => AssertPredicate<Kind>) &\n   *   ((test?: Test) => AssertAnything)\n   * )}\n   */\n  (\n    /**\n     * @param {Test} [test]\n     * @returns {AssertAnything}\n     */\n    function (test) {\n      if (test === undefined || test === null) {\n        return ok\n      }\n\n      if (typeof test === 'string') {\n        return typeFactory(test)\n      }\n\n      if (typeof test === 'object') {\n        return Array.isArray(test) ? anyFactory(test) : propsFactory(test)\n      }\n\n      if (typeof test === 'function') {\n        return castFactory(test)\n      }\n\n      throw new Error('Expected function, string, or object as test')\n    }\n  )\n\n/**\n * @param {Array<string | Props | TestFunctionAnything>} tests\n * @returns {AssertAnything}\n */\nfunction anyFactory(tests) {\n  /** @type {Array<AssertAnything>} */\n  const checks = []\n  let index = -1\n\n  while (++index < tests.length) {\n    checks[index] = convert(tests[index])\n  }\n\n  return castFactory(any)\n\n  /**\n   * @this {unknown}\n   * @param {Array<unknown>} parameters\n   * @returns {boolean}\n   */\n  function any(...parameters) {\n    let index = -1\n\n    while (++index < checks.length) {\n      if (checks[index].call(this, ...parameters)) return true\n    }\n\n    return false\n  }\n}\n\n/**\n * Turn an object into a test for a node with a certain fields.\n *\n * @param {Props} check\n * @returns {AssertAnything}\n */\nfunction propsFactory(check) {\n  return castFactory(all)\n\n  /**\n   * @param {Node} node\n   * @returns {boolean}\n   */\n  function all(node) {\n    /** @type {string} */\n    let key\n\n    for (key in check) {\n      // @ts-expect-error: hush, it sure works as an index.\n      if (node[key] !== check[key]) return false\n    }\n\n    return true\n  }\n}\n\n/**\n * Turn a string into a test for a node with a certain type.\n *\n * @param {string} check\n * @returns {AssertAnything}\n */\nfunction typeFactory(check) {\n  return castFactory(type)\n\n  /**\n   * @param {Node} node\n   */\n  function type(node) {\n    return node && node.type === check\n  }\n}\n\n/**\n * Turn a custom test into a test for a node that passes that test.\n *\n * @param {TestFunctionAnything} check\n * @returns {AssertAnything}\n */\nfunction castFactory(check) {\n  return assertion\n\n  /**\n   * @this {unknown}\n   * @param {unknown} node\n   * @param {Array<unknown>} parameters\n   * @returns {boolean}\n   */\n  function assertion(node, ...parameters) {\n    return Boolean(\n      node &&\n        typeof node === 'object' &&\n        'type' in node &&\n        // @ts-expect-error: fine.\n        Boolean(check.call(this, node, ...parameters))\n    )\n  }\n}\n\nfunction ok() {\n  return true\n}\n","/**\n * @typedef {import('mdast').PhrasingContent} PhrasingContent\n * @typedef {import('unist-util-is').AssertPredicate<PhrasingContent>} AssertPredicatePhrasing\n */\n\nimport {convert} from 'unist-util-is'\n\n/**\n * Check if the given value is *phrasing content*.\n *\n * @param\n *   Thing to check, typically `Node`.\n * @returns\n *   Whether `value` is phrasing content.\n */\nexport const phrasing = /** @type {AssertPredicatePhrasing} */ (\n  convert([\n    'break',\n    'delete',\n    'emphasis',\n    'footnote',\n    'footnoteReference',\n    'image',\n    'imageReference',\n    'inlineCode',\n    'link',\n    'linkReference',\n    'strong',\n    'text'\n  ])\n)\n","/**\n * @typedef {import('mdast').InlineCode} InlineCode\n * @typedef {import('../types.js').Parent} Parent\n * @typedef {import('../types.js').State} State\n */\n\nimport {patternCompile} from '../util/pattern-compile.js'\n\ninlineCode.peek = inlineCodePeek\n\n/**\n * @param {InlineCode} node\n * @param {Parent | undefined} _\n * @param {State} state\n * @returns {string}\n */\nexport function inlineCode(node, _, state) {\n  let value = node.value || ''\n  let sequence = '`'\n  let index = -1\n\n  // If there is a single grave accent on its own in the code, use a fence of\n  // two.\n  // If there are two in a row, use one.\n  while (new RegExp('(^|[^`])' + sequence + '([^`]|$)').test(value)) {\n    sequence += '`'\n  }\n\n  // If this is not just spaces or eols (tabs don’t count), and either the\n  // first or last character are a space, eol, or tick, then pad with spaces.\n  if (\n    /[^ \\r\\n]/.test(value) &&\n    ((/^[ \\r\\n]/.test(value) && /[ \\r\\n]$/.test(value)) || /^`|`$/.test(value))\n  ) {\n    value = ' ' + value + ' '\n  }\n\n  // We have a potential problem: certain characters after eols could result in\n  // blocks being seen.\n  // For example, if someone injected the string `'\\n# b'`, then that would\n  // result in an ATX heading.\n  // We can’t escape characters in `inlineCode`, but because eols are\n  // transformed to spaces when going from markdown to HTML anyway, we can swap\n  // them out.\n  while (++index < state.unsafe.length) {\n    const pattern = state.unsafe[index]\n    const expression = patternCompile(pattern)\n    /** @type {RegExpExecArray | null} */\n    let match\n\n    // Only look for `atBreak`s.\n    // Btw: note that `atBreak` patterns will always start the regex at LF or\n    // CR.\n    if (!pattern.atBreak) continue\n\n    while ((match = expression.exec(value))) {\n      let position = match.index\n\n      // Support CRLF (patterns only look for one of the characters).\n      if (\n        value.charCodeAt(position) === 10 /* `\\n` */ &&\n        value.charCodeAt(position - 1) === 13 /* `\\r` */\n      ) {\n        position--\n      }\n\n      value = value.slice(0, position) + ' ' + value.slice(match.index + 1)\n    }\n  }\n\n  return sequence + value + sequence\n}\n\n/**\n * @returns {string}\n */\nfunction inlineCodePeek() {\n  return '`'\n}\n","/**\n * @typedef {import('mdast').ListItem} ListItem\n * @typedef {import('../types.js').Map} Map\n * @typedef {import('../types.js').Parent} Parent\n * @typedef {import('../types.js').State} State\n * @typedef {import('../types.js').Info} Info\n */\n\nimport {checkBullet} from '../util/check-bullet.js'\nimport {checkListItemIndent} from '../util/check-list-item-indent.js'\n\n/**\n * @param {ListItem} node\n * @param {Parent | undefined} parent\n * @param {State} state\n * @param {Info} info\n * @returns {string}\n */\nexport function listItem(node, parent, state, info) {\n  const listItemIndent = checkListItemIndent(state)\n  let bullet = state.bulletCurrent || checkBullet(state)\n\n  // Add the marker value for ordered lists.\n  if (parent && parent.type === 'list' && parent.ordered) {\n    bullet =\n      (typeof parent.start === 'number' && parent.start > -1\n        ? parent.start\n        : 1) +\n      (state.options.incrementListMarker === false\n        ? 0\n        : parent.children.indexOf(node)) +\n      bullet\n  }\n\n  let size = bullet.length + 1\n\n  if (\n    listItemIndent === 'tab' ||\n    (listItemIndent === 'mixed' &&\n      ((parent && parent.type === 'list' && parent.spread) || node.spread))\n  ) {\n    size = Math.ceil(size / 4) * 4\n  }\n\n  const tracker = state.createTracker(info)\n  tracker.move(bullet + ' '.repeat(size - bullet.length))\n  tracker.shift(size)\n  const exit = state.enter('listItem')\n  const value = state.indentLines(\n    state.containerFlow(node, tracker.current()),\n    map\n  )\n  exit()\n\n  return value\n\n  /** @type {Map} */\n  function map(line, index, blank) {\n    if (index) {\n      return (blank ? '' : ' '.repeat(size)) + line\n    }\n\n    return (blank ? bullet : bullet + ' '.repeat(size - bullet.length)) + line\n  }\n}\n","/**\n * @typedef {import('../types.js').State} State\n * @typedef {import('../types.js').Options} Options\n */\n\n/**\n * @param {State} state\n * @returns {Exclude<Options['listItemIndent'], null | undefined>}\n */\nexport function checkListItemIndent(state) {\n  const style = state.options.listItemIndent || 'tab'\n\n  // To do: remove in a major.\n  // @ts-expect-error: deprecated.\n  if (style === 1 || style === '1') {\n    return 'one'\n  }\n\n  if (style !== 'tab' && style !== 'one' && style !== 'mixed') {\n    throw new Error(\n      'Cannot serialize items with `' +\n        style +\n        '` for `options.listItemIndent`, expected `tab`, `one`, or `mixed`'\n    )\n  }\n\n  return style\n}\n","/**\n * @typedef {import('../types.js').AssociationId} AssociationId\n */\n\nimport {decodeString} from 'micromark-util-decode-string'\n\n/**\n * Get an identifier from an association to match it to others.\n *\n * Associations are nodes that match to something else through an ID:\n * <https://github.com/syntax-tree/mdast#association>.\n *\n * The `label` of an association is the string value: character escapes and\n * references work, and casing is intact.\n * The `identifier` is used to match one association to another:\n * controversially, character escapes and references don’t work in this\n * matching: `&copy;` does not match `©`, and `\\+` does not match `+`.\n *\n * But casing is ignored (and whitespace) is trimmed and collapsed: ` A\\nb`\n * matches `a b`.\n * So, we do prefer the label when figuring out how we’re going to serialize:\n * it has whitespace, casing, and we can ignore most useless character\n * escapes and all character references.\n *\n * @type {AssociationId}\n */\nexport function association(node) {\n  if (node.label || !node.identifier) {\n    return node.label || ''\n  }\n\n  return decodeString(node.identifier)\n}\n","/**\n * @typedef {import('../types.js').State} State\n * @typedef {import('../types.js').Options} Options\n */\n\n/**\n * @param {State} state\n * @returns {Exclude<Options['bullet'], null | undefined>}\n */\nexport function checkBullet(state) {\n  const marker = state.options.bullet || '*'\n\n  if (marker !== '*' && marker !== '+' && marker !== '-') {\n    throw new Error(\n      'Cannot serialize items with `' +\n        marker +\n        '` for `options.bullet`, expected `*`, `+`, or `-`'\n    )\n  }\n\n  return marker\n}\n","/**\n * @typedef {import('../types.js').FlowContent} FlowContent\n * @typedef {import('../types.js').Node} Node\n * @typedef {import('../types.js').Parent} Parent\n * @typedef {import('../types.js').State} State\n * @typedef {import('../types.js').TrackFields} TrackFields\n */\n\n/**\n * @param {Parent & {children: Array<FlowContent>}} parent\n *   Parent of flow nodes.\n * @param {State} state\n *   Info passed around about the current state.\n * @param {TrackFields} info\n *   Info on where we are in the document we are generating.\n * @returns {string}\n *   Serialized children, joined by (blank) lines.\n */\nexport function containerFlow(parent, state, info) {\n  const indexStack = state.indexStack\n  const children = parent.children || []\n  const tracker = state.createTracker(info)\n  /** @type {Array<string>} */\n  const results = []\n  let index = -1\n\n  indexStack.push(-1)\n\n  while (++index < children.length) {\n    const child = children[index]\n\n    indexStack[indexStack.length - 1] = index\n\n    results.push(\n      tracker.move(\n        state.handle(child, parent, state, {\n          before: '\\n',\n          after: '\\n',\n          ...tracker.current()\n        })\n      )\n    )\n\n    if (child.type !== 'list') {\n      state.bulletLastUsed = undefined\n    }\n\n    if (index < children.length - 1) {\n      results.push(\n        tracker.move(between(child, children[index + 1], parent, state))\n      )\n    }\n  }\n\n  indexStack.pop()\n\n  return results.join('')\n}\n\n/**\n * @param {Node} left\n * @param {Node} right\n * @param {Parent} parent\n * @param {State} state\n * @returns {string}\n */\nfunction between(left, right, parent, state) {\n  let index = state.join.length\n\n  while (index--) {\n    const result = state.join[index](left, right, parent, state)\n\n    if (result === true || result === 1) {\n      break\n    }\n\n    if (typeof result === 'number') {\n      return '\\n'.repeat(1 + result)\n    }\n\n    if (result === false) {\n      return '\\n\\n<!---->\\n\\n'\n    }\n  }\n\n  return '\\n\\n'\n}\n","/**\n * @typedef {import('../types.js').Handle} Handle\n * @typedef {import('../types.js').Info} Info\n * @typedef {import('../types.js').Parent} Parent\n * @typedef {import('../types.js').PhrasingContent} PhrasingContent\n * @typedef {import('../types.js').State} State\n */\n\n/**\n * Serialize the children of a parent that contains phrasing children.\n *\n * These children will be joined flush together.\n *\n * @param {Parent & {children: Array<PhrasingContent>}} parent\n *   Parent of flow nodes.\n * @param {State} state\n *   Info passed around about the current state.\n * @param {Info} info\n *   Info on where we are in the document we are generating.\n * @returns {string}\n *   Serialized children, joined together.\n */\nexport function containerPhrasing(parent, state, info) {\n  const indexStack = state.indexStack\n  const children = parent.children || []\n  /** @type {Array<string>} */\n  const results = []\n  let index = -1\n  let before = info.before\n\n  indexStack.push(-1)\n  let tracker = state.createTracker(info)\n\n  while (++index < children.length) {\n    const child = children[index]\n    /** @type {string} */\n    let after\n\n    indexStack[indexStack.length - 1] = index\n\n    if (index + 1 < children.length) {\n      /** @type {Handle} */\n      // @ts-expect-error: hush, it’s actually a `zwitch`.\n      let handle = state.handle.handlers[children[index + 1].type]\n      /** @type {Handle} */\n      // @ts-expect-error: hush, it’s actually a `zwitch`.\n      if (handle && handle.peek) handle = handle.peek\n      after = handle\n        ? handle(children[index + 1], parent, state, {\n            before: '',\n            after: '',\n            ...tracker.current()\n          }).charAt(0)\n        : ''\n    } else {\n      after = info.after\n    }\n\n    // In some cases, html (text) can be found in phrasing right after an eol.\n    // When we’d serialize that, in most cases that would be seen as html\n    // (flow).\n    // As we can’t escape or so to prevent it from happening, we take a somewhat\n    // reasonable approach: replace that eol with a space.\n    // See: <https://github.com/syntax-tree/mdast-util-to-markdown/issues/15>\n    if (\n      results.length > 0 &&\n      (before === '\\r' || before === '\\n') &&\n      child.type === 'html'\n    ) {\n      results[results.length - 1] = results[results.length - 1].replace(\n        /(\\r?\\n|\\r)$/,\n        ' '\n      )\n      before = ' '\n\n      // To do: does this work to reset tracker?\n      tracker = state.createTracker(info)\n      tracker.move(results.join(''))\n    }\n\n    results.push(\n      tracker.move(\n        state.handle(child, parent, state, {\n          ...tracker.current(),\n          before,\n          after\n        })\n      )\n    )\n\n    before = results[results.length - 1].slice(-1)\n  }\n\n  indexStack.pop()\n\n  return results.join('')\n}\n","/**\n * @typedef {import('../types.js').IndentLines} IndentLines\n */\n\nconst eol = /\\r?\\n|\\r/g\n\n/**\n * @type {IndentLines}\n */\nexport function indentLines(value, map) {\n  /** @type {Array<string>} */\n  const result = []\n  let start = 0\n  let line = 0\n  /** @type {RegExpExecArray | null} */\n  let match\n\n  while ((match = eol.exec(value))) {\n    one(value.slice(start, match.index))\n    result.push(match[0])\n    start = match.index + match[0].length\n    line++\n  }\n\n  one(value.slice(start))\n\n  return result.join('')\n\n  /**\n   * @param {string} value\n   */\n  function one(value) {\n    result.push(map(value, line, !value))\n  }\n}\n","/**\n * @typedef {import('../types.js').Unsafe} Unsafe\n */\n\n/**\n * @param {Unsafe} pattern\n * @returns {RegExp}\n */\nexport function patternCompile(pattern) {\n  if (!pattern._compiled) {\n    const before =\n      (pattern.atBreak ? '[\\\\r\\\\n][\\\\t ]*' : '') +\n      (pattern.before ? '(?:' + pattern.before + ')' : '')\n\n    pattern._compiled = new RegExp(\n      (before ? '(' + before + ')' : '') +\n        (/[|\\\\{}()[\\]^$+*?.-]/.test(pattern.character) ? '\\\\' : '') +\n        pattern.character +\n        (pattern.after ? '(?:' + pattern.after + ')' : ''),\n      'g'\n    )\n  }\n\n  return pattern._compiled\n}\n","/**\n * @typedef {import('../types.js').Unsafe} Unsafe\n * @typedef {import('../types.js').ConstructName} ConstructName\n */\n\n/**\n * @param {Array<ConstructName>} stack\n * @param {Unsafe} pattern\n * @returns {boolean}\n */\nexport function patternInScope(stack, pattern) {\n  return (\n    listInScope(stack, pattern.inConstruct, true) &&\n    !listInScope(stack, pattern.notInConstruct, false)\n  )\n}\n\n/**\n * @param {Array<ConstructName>} stack\n * @param {Unsafe['inConstruct']} list\n * @param {boolean} none\n * @returns {boolean}\n */\nfunction listInScope(stack, list, none) {\n  if (typeof list === 'string') {\n    list = [list]\n  }\n\n  if (!list || list.length === 0) {\n    return none\n  }\n\n  let index = -1\n\n  while (++index < list.length) {\n    if (stack.includes(list[index])) {\n      return true\n    }\n  }\n\n  return false\n}\n","/**\n * @typedef {import('../types.js').State} State\n * @typedef {import('../types.js').SafeConfig} SafeConfig\n */\n\nimport {patternCompile} from './pattern-compile.js'\nimport {patternInScope} from './pattern-in-scope.js'\n\n/**\n * Make a string safe for embedding in markdown constructs.\n *\n * In markdown, almost all punctuation characters can, in certain cases,\n * result in something.\n * Whether they do is highly subjective to where they happen and in what\n * they happen.\n *\n * To solve this, `mdast-util-to-markdown` tracks:\n *\n * * Characters before and after something;\n * * What “constructs” we are in.\n *\n * This information is then used by this function to escape or encode\n * special characters.\n *\n * @param {State} state\n *   Info passed around about the current state.\n * @param {string | null | undefined} input\n *   Raw value to make safe.\n * @param {SafeConfig} config\n *   Configuration.\n * @returns {string}\n *   Serialized markdown safe for embedding.\n */\nexport function safe(state, input, config) {\n  const value = (config.before || '') + (input || '') + (config.after || '')\n  /** @type {Array<number>} */\n  const positions = []\n  /** @type {Array<string>} */\n  const result = []\n  /** @type {Record<number, {before: boolean, after: boolean}>} */\n  const infos = {}\n  let index = -1\n\n  while (++index < state.unsafe.length) {\n    const pattern = state.unsafe[index]\n\n    if (!patternInScope(state.stack, pattern)) {\n      continue\n    }\n\n    const expression = patternCompile(pattern)\n    /** @type {RegExpExecArray | null} */\n    let match\n\n    while ((match = expression.exec(value))) {\n      const before = 'before' in pattern || Boolean(pattern.atBreak)\n      const after = 'after' in pattern\n      const position = match.index + (before ? match[1].length : 0)\n\n      if (positions.includes(position)) {\n        if (infos[position].before && !before) {\n          infos[position].before = false\n        }\n\n        if (infos[position].after && !after) {\n          infos[position].after = false\n        }\n      } else {\n        positions.push(position)\n        infos[position] = {before, after}\n      }\n    }\n  }\n\n  positions.sort(numerical)\n\n  let start = config.before ? config.before.length : 0\n  const end = value.length - (config.after ? config.after.length : 0)\n  index = -1\n\n  while (++index < positions.length) {\n    const position = positions[index]\n\n    // Character before or after matched:\n    if (position < start || position >= end) {\n      continue\n    }\n\n    // If this character is supposed to be escaped because it has a condition on\n    // the next character, and the next character is definitly being escaped,\n    // then skip this escape.\n    if (\n      (position + 1 < end &&\n        positions[index + 1] === position + 1 &&\n        infos[position].after &&\n        !infos[position + 1].before &&\n        !infos[position + 1].after) ||\n      (positions[index - 1] === position - 1 &&\n        infos[position].before &&\n        !infos[position - 1].before &&\n        !infos[position - 1].after)\n    ) {\n      continue\n    }\n\n    if (start !== position) {\n      // If we have to use a character reference, an ampersand would be more\n      // correct, but as backslashes only care about punctuation, either will\n      // do the trick\n      result.push(escapeBackslashes(value.slice(start, position), '\\\\'))\n    }\n\n    start = position\n\n    if (\n      /[!-/:-@[-`{-~]/.test(value.charAt(position)) &&\n      (!config.encode || !config.encode.includes(value.charAt(position)))\n    ) {\n      // Character escape.\n      result.push('\\\\')\n    } else {\n      // Character reference.\n      result.push(\n        '&#x' + value.charCodeAt(position).toString(16).toUpperCase() + ';'\n      )\n      start++\n    }\n  }\n\n  result.push(escapeBackslashes(value.slice(start, end), config.after))\n\n  return result.join('')\n}\n\n/**\n * @param {number} a\n * @param {number} b\n * @returns {number}\n */\nfunction numerical(a, b) {\n  return a - b\n}\n\n/**\n * @param {string} value\n * @param {string} after\n * @returns {string}\n */\nfunction escapeBackslashes(value, after) {\n  const expression = /\\\\(?=[!-/:-@[-`{-~])/g\n  /** @type {Array<number>} */\n  const positions = []\n  /** @type {Array<string>} */\n  const results = []\n  const whole = value + after\n  let index = -1\n  let start = 0\n  /** @type {RegExpExecArray | null} */\n  let match\n\n  while ((match = expression.exec(whole))) {\n    positions.push(match.index)\n  }\n\n  while (++index < positions.length) {\n    if (start !== positions[index]) {\n      results.push(value.slice(start, positions[index]))\n    }\n\n    results.push('\\\\')\n    start = positions[index]\n  }\n\n  results.push(value.slice(start))\n\n  return results.join('')\n}\n","/**\n * @typedef {import('../types.js').CreateTracker} CreateTracker\n * @typedef {import('../types.js').TrackCurrent} TrackCurrent\n * @typedef {import('../types.js').TrackMove} TrackMove\n * @typedef {import('../types.js').TrackShift} TrackShift\n */\n\n/**\n * Track positional info in the output.\n *\n * @type {CreateTracker}\n */\nexport function track(config) {\n  // Defaults are used to prevent crashes when older utilities somehow activate\n  // this code.\n  /* c8 ignore next 5 */\n  const options = config || {}\n  const now = options.now || {}\n  let lineShift = options.lineShift || 0\n  let line = now.line || 1\n  let column = now.column || 1\n\n  return {move, current, shift}\n\n  /**\n   * Get the current tracked info.\n   *\n   * @type {TrackCurrent}\n   */\n  function current() {\n    return {now: {line, column}, lineShift}\n  }\n\n  /**\n   * Define an increased line shift (the typical indent for lines).\n   *\n   * @type {TrackShift}\n   */\n  function shift(value) {\n    lineShift += value\n  }\n\n  /**\n   * Move past some generated markdown.\n   *\n   * @type {TrackMove}\n   */\n  function move(input) {\n    // eslint-disable-next-line unicorn/prefer-default-parameters\n    const value = input || ''\n    const chunks = value.split(/\\r?\\n|\\r/g)\n    const tail = chunks[chunks.length - 1]\n    line += chunks.length - 1\n    column =\n      chunks.length === 1 ? column + tail.length : 1 + tail.length + lineShift\n    return value\n  }\n}\n","/**\n * @typedef {import('mdast').Root|import('mdast').Content} Node\n *\n * @typedef Options\n *   Configuration (optional).\n * @property {boolean | null | undefined} [includeImageAlt=true]\n *   Whether to use `alt` for `image`s.\n * @property {boolean | null | undefined} [includeHtml=true]\n *   Whether to use `value` of HTML.\n */\n\n/** @type {Options} */\nconst emptyOptions = {}\n\n/**\n * Get the text content of a node or list of nodes.\n *\n * Prefers the node’s plain-text fields, otherwise serializes its children,\n * and if the given value is an array, serialize the nodes in it.\n *\n * @param {unknown} value\n *   Thing to serialize, typically `Node`.\n * @param {Options | null | undefined} [options]\n *   Configuration (optional).\n * @returns {string}\n *   Serialized `value`.\n */\nexport function toString(value, options) {\n  const settings = options || emptyOptions\n  const includeImageAlt =\n    typeof settings.includeImageAlt === 'boolean'\n      ? settings.includeImageAlt\n      : true\n  const includeHtml =\n    typeof settings.includeHtml === 'boolean' ? settings.includeHtml : true\n\n  return one(value, includeImageAlt, includeHtml)\n}\n\n/**\n * One node or several nodes.\n *\n * @param {unknown} value\n *   Thing to serialize.\n * @param {boolean} includeImageAlt\n *   Include image `alt`s.\n * @param {boolean} includeHtml\n *   Include HTML.\n * @returns {string}\n *   Serialized node.\n */\nfunction one(value, includeImageAlt, includeHtml) {\n  if (node(value)) {\n    if ('value' in value) {\n      return value.type === 'html' && !includeHtml ? '' : value.value\n    }\n\n    if (includeImageAlt && 'alt' in value && value.alt) {\n      return value.alt\n    }\n\n    if ('children' in value) {\n      return all(value.children, includeImageAlt, includeHtml)\n    }\n  }\n\n  if (Array.isArray(value)) {\n    return all(value, includeImageAlt, includeHtml)\n  }\n\n  return ''\n}\n\n/**\n * Serialize a list of nodes.\n *\n * @param {Array<unknown>} values\n *   Thing to serialize.\n * @param {boolean} includeImageAlt\n *   Include image `alt`s.\n * @param {boolean} includeHtml\n *   Include HTML.\n * @returns {string}\n *   Serialized nodes.\n */\nfunction all(values, includeImageAlt, includeHtml) {\n  /** @type {Array<string>} */\n  const result = []\n  let index = -1\n\n  while (++index < values.length) {\n    result[index] = one(values[index], includeImageAlt, includeHtml)\n  }\n\n  return result.join('')\n}\n\n/**\n * Check if `value` looks like a node.\n *\n * @param {unknown} value\n *   Thing.\n * @returns {value is Node}\n *   Whether `value` is a node.\n */\nfunction node(value) {\n  return Boolean(value && typeof value === 'object')\n}\n","/**\n * Turn the number (in string form as either hexa- or plain decimal) coming from\n * a numeric character reference into a character.\n *\n * Sort of like `String.fromCharCode(Number.parseInt(value, base))`, but makes\n * non-characters and control characters safe.\n *\n * @param {string} value\n *   Value to decode.\n * @param {number} base\n *   Numeric base.\n * @returns {string}\n *   Character.\n */\nexport function decodeNumericCharacterReference(value, base) {\n  const code = Number.parseInt(value, base)\n  if (\n    // C0 except for HT, LF, FF, CR, space.\n    code < 9 ||\n    code === 11 ||\n    (code > 13 && code < 32) ||\n    // Control character (DEL) of C0, and C1 controls.\n    (code > 126 && code < 160) ||\n    // Lone high surrogates and low surrogates.\n    (code > 55295 && code < 57344) ||\n    // Noncharacters.\n    (code > 64975 && code < 65008) /* eslint-disable no-bitwise */ ||\n    (code & 65535) === 65535 ||\n    (code & 65535) === 65534 /* eslint-enable no-bitwise */ ||\n    // Out of range\n    code > 1114111\n  ) {\n    return '\\uFFFD'\n  }\n  return String.fromCharCode(code)\n}\n","import {decodeNamedCharacterReference} from 'decode-named-character-reference'\nimport {decodeNumericCharacterReference} from 'micromark-util-decode-numeric-character-reference'\nconst characterEscapeOrReference =\n  /\\\\([!-/:-@[-`{-~])|&(#(?:\\d{1,7}|x[\\da-f]{1,6})|[\\da-z]{1,31});/gi\n\n/**\n * Decode markdown strings (which occur in places such as fenced code info\n * strings, destinations, labels, and titles).\n *\n * The “string” content type allows character escapes and -references.\n * This decodes those.\n *\n * @param {string} value\n *   Value to decode.\n * @returns {string}\n *   Decoded value.\n */\nexport function decodeString(value) {\n  return value.replace(characterEscapeOrReference, decode)\n}\n\n/**\n * @param {string} $0\n * @param {string} $1\n * @param {string} $2\n * @returns {string}\n */\nfunction decode($0, $1, $2) {\n  if ($1) {\n    // Escape.\n    return $1\n  }\n\n  // Reference.\n  const head = $2.charCodeAt(0)\n  if (head === 35) {\n    const head = $2.charCodeAt(1)\n    const hex = head === 120 || head === 88\n    return decodeNumericCharacterReference($2.slice(hex ? 2 : 1), hex ? 16 : 10)\n  }\n  return decodeNamedCharacterReference($2) || $0\n}\n","/**\n * @typedef {import('./types.js').Options} Options\n * @typedef {import('./types.js').State} State\n */\n\n/**\n * @param {State} base\n * @param {Options} extension\n * @returns {State}\n */\nexport function configure(base, extension) {\n  let index = -1\n  /** @type {keyof Options} */\n  let key\n\n  // First do subextensions.\n  if (extension.extensions) {\n    while (++index < extension.extensions.length) {\n      configure(base, extension.extensions[index])\n    }\n  }\n\n  for (key in extension) {\n    if (key === 'extensions') {\n      // Empty.\n    } else if (key === 'unsafe' || key === 'join') {\n      /* c8 ignore next 2 */\n      // @ts-expect-error: hush.\n      base[key] = [...(base[key] || []), ...(extension[key] || [])]\n    } else if (key === 'handlers') {\n      base[key] = Object.assign(base[key], extension[key] || {})\n    } else {\n      // @ts-expect-error: hush.\n      base.options[key] = extension[key]\n    }\n  }\n\n  return base\n}\n","/**\n * @typedef {import('mdast').Blockquote} Blockquote\n * @typedef {import('../types.js').Parent} Parent\n * @typedef {import('../types.js').State} State\n * @typedef {import('../types.js').Info} Info\n * @typedef {import('../types.js').Map} Map\n */\n\n/**\n * @param {Blockquote} node\n * @param {Parent | undefined} _\n * @param {State} state\n * @param {Info} info\n * @returns {string}\n */\nexport function blockquote(node, _, state, info) {\n  const exit = state.enter('blockquote')\n  const tracker = state.createTracker(info)\n  tracker.move('> ')\n  tracker.shift(2)\n  const value = state.indentLines(\n    state.containerFlow(node, tracker.current()),\n    map\n  )\n  exit()\n  return value\n}\n\n/** @type {Map} */\nfunction map(line, _, blank) {\n  return '>' + (blank ? '' : ' ') + line\n}\n","/**\n * @typedef {import('mdast').Break} Break\n * @typedef {import('../types.js').Parent} Parent\n * @typedef {import('../types.js').State} State\n * @typedef {import('../types.js').Info} Info\n */\n\nimport {patternInScope} from '../util/pattern-in-scope.js'\n\n/**\n * @param {Break} _\n * @param {Parent | undefined} _1\n * @param {State} state\n * @param {Info} info\n * @returns {string}\n */\nexport function hardBreak(_, _1, state, info) {\n  let index = -1\n\n  while (++index < state.unsafe.length) {\n    // If we can’t put eols in this construct (setext headings, tables), use a\n    // space instead.\n    if (\n      state.unsafe[index].character === '\\n' &&\n      patternInScope(state.stack, state.unsafe[index])\n    ) {\n      return /[ \\t]/.test(info.before) ? '' : ' '\n    }\n  }\n\n  return '\\\\\\n'\n}\n","/**\n * @typedef {import('mdast').Code} Code\n * @typedef {import('../types.js').State} State\n */\n\n/**\n * @param {Code} node\n * @param {State} state\n * @returns {boolean}\n */\nexport function formatCodeAsIndented(node, state) {\n  return Boolean(\n    !state.options.fences &&\n      node.value &&\n      // If there’s no info…\n      !node.lang &&\n      // And there’s a non-whitespace character…\n      /[^ \\r\\n]/.test(node.value) &&\n      // And the value doesn’t start or end in a blank…\n      !/^[\\t ]*(?:[\\r\\n]|$)|(?:^|[\\r\\n])[\\t ]*$/.test(node.value)\n  )\n}\n","/**\n * @typedef {import('mdast').Code} Code\n * @typedef {import('../types.js').Parent} Parent\n * @typedef {import('../types.js').State} State\n * @typedef {import('../types.js').Info} Info\n * @typedef {import('../types.js').Map} Map\n */\n\nimport {longestStreak} from 'longest-streak'\nimport {formatCodeAsIndented} from '../util/format-code-as-indented.js'\nimport {checkFence} from '../util/check-fence.js'\n\n/**\n * @param {Code} node\n * @param {Parent | undefined} _\n * @param {State} state\n * @param {Info} info\n * @returns {string}\n */\nexport function code(node, _, state, info) {\n  const marker = checkFence(state)\n  const raw = node.value || ''\n  const suffix = marker === '`' ? 'GraveAccent' : 'Tilde'\n\n  if (formatCodeAsIndented(node, state)) {\n    const exit = state.enter('codeIndented')\n    const value = state.indentLines(raw, map)\n    exit()\n    return value\n  }\n\n  const tracker = state.createTracker(info)\n  const sequence = marker.repeat(Math.max(longestStreak(raw, marker) + 1, 3))\n  const exit = state.enter('codeFenced')\n  let value = tracker.move(sequence)\n\n  if (node.lang) {\n    const subexit = state.enter(`codeFencedLang${suffix}`)\n    value += tracker.move(\n      state.safe(node.lang, {\n        before: value,\n        after: ' ',\n        encode: ['`'],\n        ...tracker.current()\n      })\n    )\n    subexit()\n  }\n\n  if (node.lang && node.meta) {\n    const subexit = state.enter(`codeFencedMeta${suffix}`)\n    value += tracker.move(' ')\n    value += tracker.move(\n      state.safe(node.meta, {\n        before: value,\n        after: '\\n',\n        encode: ['`'],\n        ...tracker.current()\n      })\n    )\n    subexit()\n  }\n\n  value += tracker.move('\\n')\n\n  if (raw) {\n    value += tracker.move(raw + '\\n')\n  }\n\n  value += tracker.move(sequence)\n  exit()\n  return value\n}\n\n/** @type {Map} */\nfunction map(line, _, blank) {\n  return (blank ? '' : '    ') + line\n}\n","/**\n * @typedef {import('../types.js').State} State\n * @typedef {import('../types.js').Options} Options\n */\n\n/**\n * @param {State} state\n * @returns {Exclude<Options['quote'], null | undefined>}\n */\nexport function checkQuote(state) {\n  const marker = state.options.quote || '\"'\n\n  if (marker !== '\"' && marker !== \"'\") {\n    throw new Error(\n      'Cannot serialize title with `' +\n        marker +\n        '` for `options.quote`, expected `\"`, or `\\'`'\n    )\n  }\n\n  return marker\n}\n","/**\n * @typedef {import('mdast').Emphasis} Emphasis\n * @typedef {import('../types.js').Parent} Parent\n * @typedef {import('../types.js').State} State\n * @typedef {import('../types.js').Info} Info\n */\n\nimport {checkEmphasis} from '../util/check-emphasis.js'\n\nemphasis.peek = emphasisPeek\n\n// To do: there are cases where emphasis cannot “form” depending on the\n// previous or next character of sequences.\n// There’s no way around that though, except for injecting zero-width stuff.\n// Do we need to safeguard against that?\n/**\n * @param {Emphasis} node\n * @param {Parent | undefined} _\n * @param {State} state\n * @param {Info} info\n * @returns {string}\n */\nexport function emphasis(node, _, state, info) {\n  const marker = checkEmphasis(state)\n  const exit = state.enter('emphasis')\n  const tracker = state.createTracker(info)\n  let value = tracker.move(marker)\n  value += tracker.move(\n    state.containerPhrasing(node, {\n      before: value,\n      after: marker,\n      ...tracker.current()\n    })\n  )\n  value += tracker.move(marker)\n  exit()\n  return value\n}\n\n/**\n * @param {Emphasis} _\n * @param {Parent | undefined} _1\n * @param {State} state\n * @returns {string}\n */\nfunction emphasisPeek(_, _1, state) {\n  return state.options.emphasis || '*'\n}\n","/**\n * @typedef {import('../types.js').State} State\n * @typedef {import('../types.js').Options} Options\n */\n\n/**\n * @param {State} state\n * @returns {Exclude<Options['emphasis'], null | undefined>}\n */\nexport function checkEmphasis(state) {\n  const marker = state.options.emphasis || '*'\n\n  if (marker !== '*' && marker !== '_') {\n    throw new Error(\n      'Cannot serialize emphasis with `' +\n        marker +\n        '` for `options.emphasis`, expected `*`, or `_`'\n    )\n  }\n\n  return marker\n}\n","/**\n * @typedef {import('mdast').Heading} Heading\n * @typedef {import('../types.js').State} State\n */\n\nimport {visit, EXIT} from 'unist-util-visit'\nimport {toString} from 'mdast-util-to-string'\n\n/**\n * @param {Heading} node\n * @param {State} state\n * @returns {boolean}\n */\nexport function formatHeadingAsSetext(node, state) {\n  let literalWithBreak = false\n\n  // Look for literals with a line break.\n  // Note that this also\n  visit(node, (node) => {\n    if (\n      ('value' in node && /\\r?\\n|\\r/.test(node.value)) ||\n      node.type === 'break'\n    ) {\n      literalWithBreak = true\n      return EXIT\n    }\n  })\n\n  return Boolean(\n    (!node.depth || node.depth < 3) &&\n      toString(node) &&\n      (state.options.setext || literalWithBreak)\n  )\n}\n","/**\n * @typedef {import('mdast').HTML} HTML\n */\n\nhtml.peek = htmlPeek\n\n/**\n * @param {HTML} node\n * @returns {string}\n */\nexport function html(node) {\n  return node.value || ''\n}\n\n/**\n * @returns {string}\n */\nfunction htmlPeek() {\n  return '<'\n}\n","/**\n * @typedef {import('mdast').Image} Image\n * @typedef {import('../types.js').Parent} Parent\n * @typedef {import('../types.js').State} State\n * @typedef {import('../types.js').Info} Info\n */\n\nimport {checkQuote} from '../util/check-quote.js'\n\nimage.peek = imagePeek\n\n/**\n * @param {Image} node\n * @param {Parent | undefined} _\n * @param {State} state\n * @param {Info} info\n * @returns {string}\n */\nexport function image(node, _, state, info) {\n  const quote = checkQuote(state)\n  const suffix = quote === '\"' ? 'Quote' : 'Apostrophe'\n  const exit = state.enter('image')\n  let subexit = state.enter('label')\n  const tracker = state.createTracker(info)\n  let value = tracker.move('![')\n  value += tracker.move(\n    state.safe(node.alt, {before: value, after: ']', ...tracker.current()})\n  )\n  value += tracker.move('](')\n\n  subexit()\n\n  if (\n    // If there’s no url but there is a title…\n    (!node.url && node.title) ||\n    // If there are control characters or whitespace.\n    /[\\0- \\u007F]/.test(node.url)\n  ) {\n    subexit = state.enter('destinationLiteral')\n    value += tracker.move('<')\n    value += tracker.move(\n      state.safe(node.url, {before: value, after: '>', ...tracker.current()})\n    )\n    value += tracker.move('>')\n  } else {\n    // No whitespace, raw is prettier.\n    subexit = state.enter('destinationRaw')\n    value += tracker.move(\n      state.safe(node.url, {\n        before: value,\n        after: node.title ? ' ' : ')',\n        ...tracker.current()\n      })\n    )\n  }\n\n  subexit()\n\n  if (node.title) {\n    subexit = state.enter(`title${suffix}`)\n    value += tracker.move(' ' + quote)\n    value += tracker.move(\n      state.safe(node.title, {\n        before: value,\n        after: quote,\n        ...tracker.current()\n      })\n    )\n    value += tracker.move(quote)\n    subexit()\n  }\n\n  value += tracker.move(')')\n  exit()\n\n  return value\n}\n\n/**\n * @returns {string}\n */\nfunction imagePeek() {\n  return '!'\n}\n","/**\n * @typedef {import('mdast').ImageReference} ImageReference\n * @typedef {import('../types.js').Parent} Parent\n * @typedef {import('../types.js').State} State\n * @typedef {import('../types.js').Info} Info\n */\n\nimageReference.peek = imageReferencePeek\n\n/**\n * @param {ImageReference} node\n * @param {Parent | undefined} _\n * @param {State} state\n * @param {Info} info\n * @returns {string}\n */\nexport function imageReference(node, _, state, info) {\n  const type = node.referenceType\n  const exit = state.enter('imageReference')\n  let subexit = state.enter('label')\n  const tracker = state.createTracker(info)\n  let value = tracker.move('![')\n  const alt = state.safe(node.alt, {\n    before: value,\n    after: ']',\n    ...tracker.current()\n  })\n  value += tracker.move(alt + '][')\n\n  subexit()\n  // Hide the fact that we’re in phrasing, because escapes don’t work.\n  const stack = state.stack\n  state.stack = []\n  subexit = state.enter('reference')\n  // Note: for proper tracking, we should reset the output positions when we end\n  // up making a `shortcut` reference, because then there is no brace output.\n  // Practically, in that case, there is no content, so it doesn’t matter that\n  // we’ve tracked one too many characters.\n  const reference = state.safe(state.associationId(node), {\n    before: value,\n    after: ']',\n    ...tracker.current()\n  })\n  subexit()\n  state.stack = stack\n  exit()\n\n  if (type === 'full' || !alt || alt !== reference) {\n    value += tracker.move(reference + ']')\n  } else if (type === 'shortcut') {\n    // Remove the unwanted `[`.\n    value = value.slice(0, -1)\n  } else {\n    value += tracker.move(']')\n  }\n\n  return value\n}\n\n/**\n * @returns {string}\n */\nfunction imageReferencePeek() {\n  return '!'\n}\n","/**\n * @typedef {import('mdast').Link} Link\n * @typedef {import('../types.js').State} State\n */\n\nimport {toString} from 'mdast-util-to-string'\n\n/**\n * @param {Link} node\n * @param {State} state\n * @returns {boolean}\n */\nexport function formatLinkAsAutolink(node, state) {\n  const raw = toString(node)\n\n  return Boolean(\n    !state.options.resourceLink &&\n      // If there’s a url…\n      node.url &&\n      // And there’s a no title…\n      !node.title &&\n      // And the content of `node` is a single text node…\n      node.children &&\n      node.children.length === 1 &&\n      node.children[0].type === 'text' &&\n      // And if the url is the same as the content…\n      (raw === node.url || 'mailto:' + raw === node.url) &&\n      // And that starts w/ a protocol…\n      /^[a-z][a-z+.-]+:/i.test(node.url) &&\n      // And that doesn’t contain ASCII control codes (character escapes and\n      // references don’t work), space, or angle brackets…\n      !/[\\0- <>\\u007F]/.test(node.url)\n  )\n}\n","/**\n * @typedef {import('mdast').Link} Link\n * @typedef {import('../types.js').Parent} Parent\n * @typedef {import('../types.js').State} State\n * @typedef {import('../types.js').Info} Info\n * @typedef {import('../types.js').Exit} Exit\n */\n\nimport {checkQuote} from '../util/check-quote.js'\nimport {formatLinkAsAutolink} from '../util/format-link-as-autolink.js'\n\nlink.peek = linkPeek\n\n/**\n * @param {Link} node\n * @param {Parent | undefined} _\n * @param {State} state\n * @param {Info} info\n * @returns {string}\n */\nexport function link(node, _, state, info) {\n  const quote = checkQuote(state)\n  const suffix = quote === '\"' ? 'Quote' : 'Apostrophe'\n  const tracker = state.createTracker(info)\n  /** @type {Exit} */\n  let exit\n  /** @type {Exit} */\n  let subexit\n\n  if (formatLinkAsAutolink(node, state)) {\n    // Hide the fact that we’re in phrasing, because escapes don’t work.\n    const stack = state.stack\n    state.stack = []\n    exit = state.enter('autolink')\n    let value = tracker.move('<')\n    value += tracker.move(\n      state.containerPhrasing(node, {\n        before: value,\n        after: '>',\n        ...tracker.current()\n      })\n    )\n    value += tracker.move('>')\n    exit()\n    state.stack = stack\n    return value\n  }\n\n  exit = state.enter('link')\n  subexit = state.enter('label')\n  let value = tracker.move('[')\n  value += tracker.move(\n    state.containerPhrasing(node, {\n      before: value,\n      after: '](',\n      ...tracker.current()\n    })\n  )\n  value += tracker.move('](')\n  subexit()\n\n  if (\n    // If there’s no url but there is a title…\n    (!node.url && node.title) ||\n    // If there are control characters or whitespace.\n    /[\\0- \\u007F]/.test(node.url)\n  ) {\n    subexit = state.enter('destinationLiteral')\n    value += tracker.move('<')\n    value += tracker.move(\n      state.safe(node.url, {before: value, after: '>', ...tracker.current()})\n    )\n    value += tracker.move('>')\n  } else {\n    // No whitespace, raw is prettier.\n    subexit = state.enter('destinationRaw')\n    value += tracker.move(\n      state.safe(node.url, {\n        before: value,\n        after: node.title ? ' ' : ')',\n        ...tracker.current()\n      })\n    )\n  }\n\n  subexit()\n\n  if (node.title) {\n    subexit = state.enter(`title${suffix}`)\n    value += tracker.move(' ' + quote)\n    value += tracker.move(\n      state.safe(node.title, {\n        before: value,\n        after: quote,\n        ...tracker.current()\n      })\n    )\n    value += tracker.move(quote)\n    subexit()\n  }\n\n  value += tracker.move(')')\n\n  exit()\n  return value\n}\n\n/**\n * @param {Link} node\n * @param {Parent | undefined} _\n * @param {State} state\n * @returns {string}\n */\nfunction linkPeek(node, _, state) {\n  return formatLinkAsAutolink(node, state) ? '<' : '['\n}\n","/**\n * @typedef {import('mdast').LinkReference} LinkReference\n * @typedef {import('../types.js').Parent} Parent\n * @typedef {import('../types.js').State} State\n * @typedef {import('../types.js').Info} Info\n */\n\nlinkReference.peek = linkReferencePeek\n\n/**\n * @param {LinkReference} node\n * @param {Parent | undefined} _\n * @param {State} state\n * @param {Info} info\n * @returns {string}\n */\nexport function linkReference(node, _, state, info) {\n  const type = node.referenceType\n  const exit = state.enter('linkReference')\n  let subexit = state.enter('label')\n  const tracker = state.createTracker(info)\n  let value = tracker.move('[')\n  const text = state.containerPhrasing(node, {\n    before: value,\n    after: ']',\n    ...tracker.current()\n  })\n  value += tracker.move(text + '][')\n\n  subexit()\n  // Hide the fact that we’re in phrasing, because escapes don’t work.\n  const stack = state.stack\n  state.stack = []\n  subexit = state.enter('reference')\n  // Note: for proper tracking, we should reset the output positions when we end\n  // up making a `shortcut` reference, because then there is no brace output.\n  // Practically, in that case, there is no content, so it doesn’t matter that\n  // we’ve tracked one too many characters.\n  const reference = state.safe(state.associationId(node), {\n    before: value,\n    after: ']',\n    ...tracker.current()\n  })\n  subexit()\n  state.stack = stack\n  exit()\n\n  if (type === 'full' || !text || text !== reference) {\n    value += tracker.move(reference + ']')\n  } else if (type === 'shortcut') {\n    // Remove the unwanted `[`.\n    value = value.slice(0, -1)\n  } else {\n    value += tracker.move(']')\n  }\n\n  return value\n}\n\n/**\n * @returns {string}\n */\nfunction linkReferencePeek() {\n  return '['\n}\n","/**\n * @typedef {import('../types.js').State} State\n * @typedef {import('../types.js').Options} Options\n */\n\n/**\n * @param {State} state\n * @returns {Exclude<Options['bulletOrdered'], null | undefined>}\n */\nexport function checkBulletOrdered(state) {\n  const marker = state.options.bulletOrdered || '.'\n\n  if (marker !== '.' && marker !== ')') {\n    throw new Error(\n      'Cannot serialize items with `' +\n        marker +\n        '` for `options.bulletOrdered`, expected `.` or `)`'\n    )\n  }\n\n  return marker\n}\n","/**\n * @typedef {import('../types.js').State} State\n * @typedef {import('../types.js').Options} Options\n */\n\n/**\n * @param {State} state\n * @returns {Exclude<Options['rule'], null | undefined>}\n */\nexport function checkRule(state) {\n  const marker = state.options.rule || '*'\n\n  if (marker !== '*' && marker !== '-' && marker !== '_') {\n    throw new Error(\n      'Cannot serialize rules with `' +\n        marker +\n        '` for `options.rule`, expected `*`, `-`, or `_`'\n    )\n  }\n\n  return marker\n}\n","/**\n * @typedef {import('mdast').Strong} Strong\n * @typedef {import('../types.js').Parent} Parent\n * @typedef {import('../types.js').State} State\n * @typedef {import('../types.js').Info} Info\n */\n\nimport {checkStrong} from '../util/check-strong.js'\n\nstrong.peek = strongPeek\n\n// To do: there are cases where emphasis cannot “form” depending on the\n// previous or next character of sequences.\n// There’s no way around that though, except for injecting zero-width stuff.\n// Do we need to safeguard against that?\n/**\n * @param {Strong} node\n * @param {Parent | undefined} _\n * @param {State} state\n * @param {Info} info\n * @returns {string}\n */\nexport function strong(node, _, state, info) {\n  const marker = checkStrong(state)\n  const exit = state.enter('strong')\n  const tracker = state.createTracker(info)\n  let value = tracker.move(marker + marker)\n  value += tracker.move(\n    state.containerPhrasing(node, {\n      before: value,\n      after: marker,\n      ...tracker.current()\n    })\n  )\n  value += tracker.move(marker + marker)\n  exit()\n  return value\n}\n\n/**\n * @param {Strong} _\n * @param {Parent | undefined} _1\n * @param {State} state\n * @returns {string}\n */\nfunction strongPeek(_, _1, state) {\n  return state.options.strong || '*'\n}\n","/**\n * @typedef {import('../types.js').State} State\n * @typedef {import('../types.js').Options} Options\n */\n\n/**\n * @param {State} state\n * @returns {Exclude<Options['strong'], null | undefined>}\n */\nexport function checkStrong(state) {\n  const marker = state.options.strong || '*'\n\n  if (marker !== '*' && marker !== '_') {\n    throw new Error(\n      'Cannot serialize strong with `' +\n        marker +\n        '` for `options.strong`, expected `*`, or `_`'\n    )\n  }\n\n  return marker\n}\n","import {blockquote} from './blockquote.js'\nimport {hardBreak} from './break.js'\nimport {code} from './code.js'\nimport {definition} from './definition.js'\nimport {emphasis} from './emphasis.js'\nimport {heading} from './heading.js'\nimport {html} from './html.js'\nimport {image} from './image.js'\nimport {imageReference} from './image-reference.js'\nimport {inlineCode} from './inline-code.js'\nimport {link} from './link.js'\nimport {linkReference} from './link-reference.js'\nimport {list} from './list.js'\nimport {listItem} from './list-item.js'\nimport {paragraph} from './paragraph.js'\nimport {root} from './root.js'\nimport {strong} from './strong.js'\nimport {text} from './text.js'\nimport {thematicBreak} from './thematic-break.js'\n\n/**\n * Default (CommonMark) handlers.\n */\nexport const handle = {\n  blockquote,\n  break: hardBreak,\n  code,\n  definition,\n  emphasis,\n  hardBreak,\n  heading,\n  html,\n  image,\n  imageReference,\n  inlineCode,\n  link,\n  linkReference,\n  list,\n  listItem,\n  paragraph,\n  root,\n  strong,\n  text,\n  thematicBreak\n}\n","/**\n * @typedef {import('../types.js').State} State\n * @typedef {import('../types.js').Options} Options\n */\n\n/**\n * @param {State} state\n * @returns {Exclude<Options['fence'], null | undefined>}\n */\nexport function checkFence(state) {\n  const marker = state.options.fence || '`'\n\n  if (marker !== '`' && marker !== '~') {\n    throw new Error(\n      'Cannot serialize code with `' +\n        marker +\n        '` for `options.fence`, expected `` ` `` or `~`'\n    )\n  }\n\n  return marker\n}\n","/**\n * Get the count of the longest repeating streak of `substring` in `value`.\n *\n * @param {string} value\n *   Content to search in.\n * @param {string} substring\n *   Substring to look for, typically one character.\n * @returns {number}\n *   Count of most frequent adjacent `substring`s in `value`.\n */\nexport function longestStreak(value, substring) {\n  const source = String(value)\n  let index = source.indexOf(substring)\n  let expected = index\n  let count = 0\n  let max = 0\n\n  if (typeof substring !== 'string') {\n    throw new TypeError('Expected substring')\n  }\n\n  while (index !== -1) {\n    if (index === expected) {\n      if (++count > max) {\n        max = count\n      }\n    } else {\n      count = 1\n    }\n\n    expected = index + substring.length\n    index = source.indexOf(substring, expected)\n  }\n\n  return max\n}\n","/**\n * @typedef {import('mdast').Definition} Definition\n * @typedef {import('../types.js').Parent} Parent\n * @typedef {import('../types.js').State} State\n * @typedef {import('../types.js').Info} Info\n */\n\nimport {checkQuote} from '../util/check-quote.js'\n\n/**\n * @param {Definition} node\n * @param {Parent | undefined} _\n * @param {State} state\n * @param {Info} info\n * @returns {string}\n */\nexport function definition(node, _, state, info) {\n  const quote = checkQuote(state)\n  const suffix = quote === '\"' ? 'Quote' : 'Apostrophe'\n  const exit = state.enter('definition')\n  let subexit = state.enter('label')\n  const tracker = state.createTracker(info)\n  let value = tracker.move('[')\n  value += tracker.move(\n    state.safe(state.associationId(node), {\n      before: value,\n      after: ']',\n      ...tracker.current()\n    })\n  )\n  value += tracker.move(']: ')\n\n  subexit()\n\n  if (\n    // If there’s no url, or…\n    !node.url ||\n    // If there are control characters or whitespace.\n    /[\\0- \\u007F]/.test(node.url)\n  ) {\n    subexit = state.enter('destinationLiteral')\n    value += tracker.move('<')\n    value += tracker.move(\n      state.safe(node.url, {before: value, after: '>', ...tracker.current()})\n    )\n    value += tracker.move('>')\n  } else {\n    // No whitespace, raw is prettier.\n    subexit = state.enter('destinationRaw')\n    value += tracker.move(\n      state.safe(node.url, {\n        before: value,\n        after: node.title ? ' ' : '\\n',\n        ...tracker.current()\n      })\n    )\n  }\n\n  subexit()\n\n  if (node.title) {\n    subexit = state.enter(`title${suffix}`)\n    value += tracker.move(' ' + quote)\n    value += tracker.move(\n      state.safe(node.title, {\n        before: value,\n        after: quote,\n        ...tracker.current()\n      })\n    )\n    value += tracker.move(quote)\n    subexit()\n  }\n\n  exit()\n\n  return value\n}\n","/**\n * @typedef {import('mdast').Heading} Heading\n * @typedef {import('../types.js').Parent} Parent\n * @typedef {import('../types.js').State} State\n * @typedef {import('../types.js').Info} Info\n */\n\nimport {formatHeadingAsSetext} from '../util/format-heading-as-setext.js'\n\n/**\n * @param {Heading} node\n * @param {Parent | undefined} _\n * @param {State} state\n * @param {Info} info\n * @returns {string}\n */\nexport function heading(node, _, state, info) {\n  const rank = Math.max(Math.min(6, node.depth || 1), 1)\n  const tracker = state.createTracker(info)\n\n  if (formatHeadingAsSetext(node, state)) {\n    const exit = state.enter('headingSetext')\n    const subexit = state.enter('phrasing')\n    const value = state.containerPhrasing(node, {\n      ...tracker.current(),\n      before: '\\n',\n      after: '\\n'\n    })\n    subexit()\n    exit()\n\n    return (\n      value +\n      '\\n' +\n      (rank === 1 ? '=' : '-').repeat(\n        // The whole size…\n        value.length -\n          // Minus the position of the character after the last EOL (or\n          // 0 if there is none)…\n          (Math.max(value.lastIndexOf('\\r'), value.lastIndexOf('\\n')) + 1)\n      )\n    )\n  }\n\n  const sequence = '#'.repeat(rank)\n  const exit = state.enter('headingAtx')\n  const subexit = state.enter('phrasing')\n\n  // Note: for proper tracking, we should reset the output positions when there\n  // is no content returned, because then the space is not output.\n  // Practically, in that case, there is no content, so it doesn’t matter that\n  // we’ve tracked one too many characters.\n  tracker.move(sequence + ' ')\n\n  let value = state.containerPhrasing(node, {\n    before: '# ',\n    after: '\\n',\n    ...tracker.current()\n  })\n\n  if (/^[\\t ]/.test(value)) {\n    // To do: what effect has the character reference on tracking?\n    value =\n      '&#x' +\n      value.charCodeAt(0).toString(16).toUpperCase() +\n      ';' +\n      value.slice(1)\n  }\n\n  value = value ? sequence + ' ' + value : sequence\n\n  if (state.options.closeAtx) {\n    value += ' ' + sequence\n  }\n\n  subexit()\n  exit()\n\n  return value\n}\n","/**\n * @typedef {import('mdast').List} List\n * @typedef {import('../types.js').Parent} Parent\n * @typedef {import('../types.js').State} State\n * @typedef {import('../types.js').Info} Info\n */\n\nimport {checkBullet} from '../util/check-bullet.js'\nimport {checkBulletOther} from '../util/check-bullet-other.js'\nimport {checkBulletOrdered} from '../util/check-bullet-ordered.js'\nimport {checkBulletOrderedOther} from '../util/check-bullet-ordered-other.js'\nimport {checkRule} from '../util/check-rule.js'\n\n/**\n * @param {List} node\n * @param {Parent | undefined} parent\n * @param {State} state\n * @param {Info} info\n * @returns {string}\n */\nexport function list(node, parent, state, info) {\n  const exit = state.enter('list')\n  const bulletCurrent = state.bulletCurrent\n  /** @type {string} */\n  let bullet = node.ordered ? checkBulletOrdered(state) : checkBullet(state)\n  /** @type {string} */\n  const bulletOther = node.ordered\n    ? checkBulletOrderedOther(state)\n    : checkBulletOther(state)\n  const bulletLastUsed = state.bulletLastUsed\n  let useDifferentMarker = false\n\n  if (\n    parent &&\n    // Explicit `other` set.\n    (node.ordered\n      ? state.options.bulletOrderedOther\n      : state.options.bulletOther) &&\n    bulletLastUsed &&\n    bullet === bulletLastUsed\n  ) {\n    useDifferentMarker = true\n  }\n\n  if (!node.ordered) {\n    const firstListItem = node.children ? node.children[0] : undefined\n\n    // If there’s an empty first list item directly in two list items,\n    // we have to use a different bullet:\n    //\n    // ```markdown\n    // * - *\n    // ```\n    //\n    // …because otherwise it would become one big thematic break.\n    if (\n      // Bullet could be used as a thematic break marker:\n      (bullet === '*' || bullet === '-') &&\n      // Empty first list item:\n      firstListItem &&\n      (!firstListItem.children || !firstListItem.children[0]) &&\n      // Directly in two other list items:\n      state.stack[state.stack.length - 1] === 'list' &&\n      state.stack[state.stack.length - 2] === 'listItem' &&\n      state.stack[state.stack.length - 3] === 'list' &&\n      state.stack[state.stack.length - 4] === 'listItem' &&\n      // That are each the first child.\n      state.indexStack[state.indexStack.length - 1] === 0 &&\n      state.indexStack[state.indexStack.length - 2] === 0 &&\n      state.indexStack[state.indexStack.length - 3] === 0\n    ) {\n      useDifferentMarker = true\n    }\n\n    // If there’s a thematic break at the start of the first list item,\n    // we have to use a different bullet:\n    //\n    // ```markdown\n    // * ---\n    // ```\n    //\n    // …because otherwise it would become one big thematic break.\n    if (checkRule(state) === bullet && firstListItem) {\n      let index = -1\n\n      while (++index < node.children.length) {\n        const item = node.children[index]\n\n        if (\n          item &&\n          item.type === 'listItem' &&\n          item.children &&\n          item.children[0] &&\n          item.children[0].type === 'thematicBreak'\n        ) {\n          useDifferentMarker = true\n          break\n        }\n      }\n    }\n  }\n\n  if (useDifferentMarker) {\n    bullet = bulletOther\n  }\n\n  state.bulletCurrent = bullet\n  const value = state.containerFlow(node, info)\n  state.bulletLastUsed = bullet\n  state.bulletCurrent = bulletCurrent\n  exit()\n  return value\n}\n","/**\n * @typedef {import('../types.js').State} State\n * @typedef {import('../types.js').Options} Options\n */\n\nimport {checkBulletOrdered} from './check-bullet-ordered.js'\n\n/**\n * @param {State} state\n * @returns {Exclude<Options['bulletOrdered'], null | undefined>}\n */\nexport function checkBulletOrderedOther(state) {\n  const bulletOrdered = checkBulletOrdered(state)\n  const bulletOrderedOther = state.options.bulletOrderedOther\n\n  if (!bulletOrderedOther) {\n    return bulletOrdered === '.' ? ')' : '.'\n  }\n\n  if (bulletOrderedOther !== '.' && bulletOrderedOther !== ')') {\n    throw new Error(\n      'Cannot serialize items with `' +\n        bulletOrderedOther +\n        '` for `options.bulletOrderedOther`, expected `*`, `+`, or `-`'\n    )\n  }\n\n  if (bulletOrderedOther === bulletOrdered) {\n    throw new Error(\n      'Expected `bulletOrdered` (`' +\n        bulletOrdered +\n        '`) and `bulletOrderedOther` (`' +\n        bulletOrderedOther +\n        '`) to be different'\n    )\n  }\n\n  return bulletOrderedOther\n}\n","/**\n * @typedef {import('../types.js').State} State\n * @typedef {import('../types.js').Options} Options\n */\n\nimport {checkBullet} from './check-bullet.js'\n\n/**\n * @param {State} state\n * @returns {Exclude<Options['bullet'], null | undefined>}\n */\nexport function checkBulletOther(state) {\n  const bullet = checkBullet(state)\n  const bulletOther = state.options.bulletOther\n\n  if (!bulletOther) {\n    return bullet === '*' ? '-' : '*'\n  }\n\n  if (bulletOther !== '*' && bulletOther !== '+' && bulletOther !== '-') {\n    throw new Error(\n      'Cannot serialize items with `' +\n        bulletOther +\n        '` for `options.bulletOther`, expected `*`, `+`, or `-`'\n    )\n  }\n\n  if (bulletOther === bullet) {\n    throw new Error(\n      'Expected `bullet` (`' +\n        bullet +\n        '`) and `bulletOther` (`' +\n        bulletOther +\n        '`) to be different'\n    )\n  }\n\n  return bulletOther\n}\n","/**\n * @typedef {import('mdast').Paragraph} Paragraph\n * @typedef {import('../types.js').Parent} Parent\n * @typedef {import('../types.js').State} State\n * @typedef {import('../types.js').Info} Info\n */\n\n/**\n * @param {Paragraph} node\n * @param {Parent | undefined} _\n * @param {State} state\n * @param {Info} info\n * @returns {string}\n */\nexport function paragraph(node, _, state, info) {\n  const exit = state.enter('paragraph')\n  const subexit = state.enter('phrasing')\n  const value = state.containerPhrasing(node, info)\n  subexit()\n  exit()\n  return value\n}\n","/**\n * @typedef {import('mdast').Root} Root\n * @typedef {import('../types.js').Parent} Parent\n * @typedef {import('../types.js').State} State\n * @typedef {import('../types.js').Info} Info\n */\n\nimport {phrasing} from 'mdast-util-phrasing'\n\n/**\n * @param {Root} node\n * @param {Parent | undefined} _\n * @param {State} state\n * @param {Info} info\n * @returns {string}\n */\nexport function root(node, _, state, info) {\n  // Note: `html` nodes are ambiguous.\n  const hasPhrasing = node.children.some((d) => phrasing(d))\n  const fn = hasPhrasing ? state.containerPhrasing : state.containerFlow\n  // @ts-expect-error: `root`s are supposed to have one type of content\n  return fn.call(state, node, info)\n}\n","/**\n * @typedef {import('mdast').Text} Text\n * @typedef {import('../types.js').Parent} Parent\n * @typedef {import('../types.js').State} State\n * @typedef {import('../types.js').Info} Info\n */\n\n/**\n * @param {Text} node\n * @param {Parent | undefined} _\n * @param {State} state\n * @param {Info} info\n * @returns {string}\n */\nexport function text(node, _, state, info) {\n  return state.safe(node.value, info)\n}\n","/**\n * @typedef {import('mdast').ThematicBreak} ThematicBreak\n * @typedef {import('../types.js').Parent} Parent\n * @typedef {import('../types.js').State} State\n */\n\nimport {checkRuleRepetition} from '../util/check-rule-repetition.js'\nimport {checkRule} from '../util/check-rule.js'\n\n/**\n * @param {ThematicBreak} _\n * @param {Parent | undefined} _1\n * @param {State} state\n * @returns {string}\n */\nexport function thematicBreak(_, _1, state) {\n  const value = (\n    checkRule(state) + (state.options.ruleSpaces ? ' ' : '')\n  ).repeat(checkRuleRepetition(state))\n\n  return state.options.ruleSpaces ? value.slice(0, -1) : value\n}\n","/**\n * @typedef {import('../types.js').State} State\n * @typedef {import('../types.js').Options} Options\n */\n\n/**\n * @param {State} state\n * @returns {Exclude<Options['ruleRepetition'], null | undefined>}\n */\nexport function checkRuleRepetition(state) {\n  const repetition = state.options.ruleRepetition || 3\n\n  if (repetition < 3) {\n    throw new Error(\n      'Cannot serialize rules with repetition `' +\n        repetition +\n        '` for `options.ruleRepetition`, expected `3` or more'\n    )\n  }\n\n  return repetition\n}\n","/**\n * @typedef {import('./types.js').Join} Join\n */\n\nimport {formatCodeAsIndented} from './util/format-code-as-indented.js'\nimport {formatHeadingAsSetext} from './util/format-heading-as-setext.js'\n\n/** @type {Array<Join>} */\nexport const join = [joinDefaults]\n\n/** @type {Join} */\nfunction joinDefaults(left, right, parent, state) {\n  // Indented code after list or another indented code.\n  if (\n    right.type === 'code' &&\n    formatCodeAsIndented(right, state) &&\n    (left.type === 'list' ||\n      (left.type === right.type && formatCodeAsIndented(left, state)))\n  ) {\n    return false\n  }\n\n  // Two lists with the same marker.\n  if (\n    left.type === 'list' &&\n    left.type === right.type &&\n    Boolean(left.ordered) === Boolean(right.ordered) &&\n    !(left.ordered\n      ? state.options.bulletOrderedOther\n      : state.options.bulletOther)\n  ) {\n    return false\n  }\n\n  // Join children of a list or an item.\n  // In which case, `parent` has a `spread` field.\n  if ('spread' in parent && typeof parent.spread === 'boolean') {\n    if (\n      left.type === 'paragraph' &&\n      // Two paragraphs.\n      (left.type === right.type ||\n        right.type === 'definition' ||\n        // Paragraph followed by a setext heading.\n        (right.type === 'heading' && formatHeadingAsSetext(right, state)))\n    ) {\n      return\n    }\n\n    return parent.spread ? 1 : 0\n  }\n}\n","/**\n * @typedef {import('./types.js').Unsafe} Unsafe\n * @typedef {import('./types.js').ConstructName} ConstructName\n */\n\n/**\n * List of constructs that occur in phrasing (paragraphs, headings), but cannot\n * contain things like attention (emphasis, strong), images, or links.\n * So they sort of cancel each other out.\n * Note: could use a better name.\n *\n * @type {Array<ConstructName>}\n */\nconst fullPhrasingSpans = [\n  'autolink',\n  'destinationLiteral',\n  'destinationRaw',\n  'reference',\n  'titleQuote',\n  'titleApostrophe'\n]\n\n/** @type {Array<Unsafe>} */\nexport const unsafe = [\n  {character: '\\t', after: '[\\\\r\\\\n]', inConstruct: 'phrasing'},\n  {character: '\\t', before: '[\\\\r\\\\n]', inConstruct: 'phrasing'},\n  {\n    character: '\\t',\n    inConstruct: ['codeFencedLangGraveAccent', 'codeFencedLangTilde']\n  },\n  {\n    character: '\\r',\n    inConstruct: [\n      'codeFencedLangGraveAccent',\n      'codeFencedLangTilde',\n      'codeFencedMetaGraveAccent',\n      'codeFencedMetaTilde',\n      'destinationLiteral',\n      'headingAtx'\n    ]\n  },\n  {\n    character: '\\n',\n    inConstruct: [\n      'codeFencedLangGraveAccent',\n      'codeFencedLangTilde',\n      'codeFencedMetaGraveAccent',\n      'codeFencedMetaTilde',\n      'destinationLiteral',\n      'headingAtx'\n    ]\n  },\n  {character: ' ', after: '[\\\\r\\\\n]', inConstruct: 'phrasing'},\n  {character: ' ', before: '[\\\\r\\\\n]', inConstruct: 'phrasing'},\n  {\n    character: ' ',\n    inConstruct: ['codeFencedLangGraveAccent', 'codeFencedLangTilde']\n  },\n  // An exclamation mark can start an image, if it is followed by a link or\n  // a link reference.\n  {\n    character: '!',\n    after: '\\\\[',\n    inConstruct: 'phrasing',\n    notInConstruct: fullPhrasingSpans\n  },\n  // A quote can break out of a title.\n  {character: '\"', inConstruct: 'titleQuote'},\n  // A number sign could start an ATX heading if it starts a line.\n  {atBreak: true, character: '#'},\n  {character: '#', inConstruct: 'headingAtx', after: '(?:[\\r\\n]|$)'},\n  // Dollar sign and percentage are not used in markdown.\n  // An ampersand could start a character reference.\n  {character: '&', after: '[#A-Za-z]', inConstruct: 'phrasing'},\n  // An apostrophe can break out of a title.\n  {character: \"'\", inConstruct: 'titleApostrophe'},\n  // A left paren could break out of a destination raw.\n  {character: '(', inConstruct: 'destinationRaw'},\n  // A left paren followed by `]` could make something into a link or image.\n  {\n    before: '\\\\]',\n    character: '(',\n    inConstruct: 'phrasing',\n    notInConstruct: fullPhrasingSpans\n  },\n  // A right paren could start a list item or break out of a destination\n  // raw.\n  {atBreak: true, before: '\\\\d+', character: ')'},\n  {character: ')', inConstruct: 'destinationRaw'},\n  // An asterisk can start thematic breaks, list items, emphasis, strong.\n  {atBreak: true, character: '*', after: '(?:[ \\t\\r\\n*])'},\n  {character: '*', inConstruct: 'phrasing', notInConstruct: fullPhrasingSpans},\n  // A plus sign could start a list item.\n  {atBreak: true, character: '+', after: '(?:[ \\t\\r\\n])'},\n  // A dash can start thematic breaks, list items, and setext heading\n  // underlines.\n  {atBreak: true, character: '-', after: '(?:[ \\t\\r\\n-])'},\n  // A dot could start a list item.\n  {atBreak: true, before: '\\\\d+', character: '.', after: '(?:[ \\t\\r\\n]|$)'},\n  // Slash, colon, and semicolon are not used in markdown for constructs.\n  // A less than can start html (flow or text) or an autolink.\n  // HTML could start with an exclamation mark (declaration, cdata, comment),\n  // slash (closing tag), question mark (instruction), or a letter (tag).\n  // An autolink also starts with a letter.\n  // Finally, it could break out of a destination literal.\n  {atBreak: true, character: '<', after: '[!/?A-Za-z]'},\n  {\n    character: '<',\n    after: '[!/?A-Za-z]',\n    inConstruct: 'phrasing',\n    notInConstruct: fullPhrasingSpans\n  },\n  {character: '<', inConstruct: 'destinationLiteral'},\n  // An equals to can start setext heading underlines.\n  {atBreak: true, character: '='},\n  // A greater than can start block quotes and it can break out of a\n  // destination literal.\n  {atBreak: true, character: '>'},\n  {character: '>', inConstruct: 'destinationLiteral'},\n  // Question mark and at sign are not used in markdown for constructs.\n  // A left bracket can start definitions, references, labels,\n  {atBreak: true, character: '['},\n  {character: '[', inConstruct: 'phrasing', notInConstruct: fullPhrasingSpans},\n  {character: '[', inConstruct: ['label', 'reference']},\n  // A backslash can start an escape (when followed by punctuation) or a\n  // hard break (when followed by an eol).\n  // Note: typical escapes are handled in `safe`!\n  {character: '\\\\', after: '[\\\\r\\\\n]', inConstruct: 'phrasing'},\n  // A right bracket can exit labels.\n  {character: ']', inConstruct: ['label', 'reference']},\n  // Caret is not used in markdown for constructs.\n  // An underscore can start emphasis, strong, or a thematic break.\n  {atBreak: true, character: '_'},\n  {character: '_', inConstruct: 'phrasing', notInConstruct: fullPhrasingSpans},\n  // A grave accent can start code (fenced or text), or it can break out of\n  // a grave accent code fence.\n  {atBreak: true, character: '`'},\n  {\n    character: '`',\n    inConstruct: ['codeFencedLangGraveAccent', 'codeFencedMetaGraveAccent']\n  },\n  {character: '`', inConstruct: 'phrasing', notInConstruct: fullPhrasingSpans},\n  // Left brace, vertical bar, right brace are not used in markdown for\n  // constructs.\n  // A tilde can start code (fenced).\n  {atBreak: true, character: '~'}\n]\n","/**\n * @typedef {import('./types.js').Enter} Enter\n * @typedef {import('./types.js').Info} Info\n * @typedef {import('./types.js').Join} Join\n * @typedef {import('./types.js').FlowContent} FlowContent\n * @typedef {import('./types.js').Node} Node\n * @typedef {import('./types.js').Options} Options\n * @typedef {import('./types.js').Parent} Parent\n * @typedef {import('./types.js').PhrasingContent} PhrasingContent\n * @typedef {import('./types.js').SafeConfig} SafeConfig\n * @typedef {import('./types.js').State} State\n * @typedef {import('./types.js').TrackFields} TrackFields\n */\n\nimport {zwitch} from 'zwitch'\nimport {configure} from './configure.js'\nimport {handle as handlers} from './handle/index.js'\nimport {join} from './join.js'\nimport {unsafe} from './unsafe.js'\nimport {association} from './util/association.js'\nimport {containerPhrasing} from './util/container-phrasing.js'\nimport {containerFlow} from './util/container-flow.js'\nimport {indentLines} from './util/indent-lines.js'\nimport {safe} from './util/safe.js'\nimport {track} from './util/track.js'\n\n/**\n * Turn an mdast syntax tree into markdown.\n *\n * @param {Node} tree\n *   Tree to serialize.\n * @param {Options} [options]\n *   Configuration (optional).\n * @returns {string}\n *   Serialized markdown representing `tree`.\n */\nexport function toMarkdown(tree, options = {}) {\n  /** @type {State} */\n  const state = {\n    enter,\n    indentLines,\n    associationId: association,\n    containerPhrasing: containerPhrasingBound,\n    containerFlow: containerFlowBound,\n    createTracker: track,\n    safe: safeBound,\n    stack: [],\n    unsafe: [],\n    join: [],\n    // @ts-expect-error: we’ll fill it next.\n    handlers: {},\n    options: {},\n    indexStack: [],\n    // @ts-expect-error: we’ll add `handle` later.\n    handle: undefined\n  }\n\n  configure(state, {unsafe, join, handlers})\n  configure(state, options)\n\n  if (state.options.tightDefinitions) {\n    configure(state, {join: [joinDefinition]})\n  }\n\n  state.handle = zwitch('type', {\n    invalid,\n    unknown,\n    handlers: state.handlers\n  })\n\n  let result = state.handle(tree, undefined, state, {\n    before: '\\n',\n    after: '\\n',\n    now: {line: 1, column: 1},\n    lineShift: 0\n  })\n\n  if (\n    result &&\n    result.charCodeAt(result.length - 1) !== 10 &&\n    result.charCodeAt(result.length - 1) !== 13\n  ) {\n    result += '\\n'\n  }\n\n  return result\n\n  /** @type {Enter} */\n  function enter(name) {\n    state.stack.push(name)\n    return exit\n\n    function exit() {\n      state.stack.pop()\n    }\n  }\n}\n\n/**\n * @param {unknown} value\n * @returns {never}\n */\nfunction invalid(value) {\n  throw new Error('Cannot handle value `' + value + '`, expected node')\n}\n\n/**\n * @param {unknown} node\n * @returns {never}\n */\nfunction unknown(node) {\n  // @ts-expect-error: fine.\n  throw new Error('Cannot handle unknown node `' + node.type + '`')\n}\n\n/** @type {Join} */\nfunction joinDefinition(left, right) {\n  // No blank line between adjacent definitions.\n  if (left.type === 'definition' && left.type === right.type) {\n    return 0\n  }\n}\n\n/**\n * Serialize the children of a parent that contains phrasing children.\n *\n * These children will be joined flush together.\n *\n * @this {State}\n *   Info passed around about the current state.\n * @param {Parent & {children: Array<PhrasingContent>}} parent\n *   Parent of flow nodes.\n * @param {Info} info\n *   Info on where we are in the document we are generating.\n * @returns {string}\n *   Serialized children, joined together.\n */\nfunction containerPhrasingBound(parent, info) {\n  return containerPhrasing(parent, this, info)\n}\n\n/**\n * Serialize the children of a parent that contains flow children.\n *\n * These children will typically be joined by blank lines.\n * What they are joined by exactly is defined by `Join` functions.\n *\n * @this {State}\n *   Info passed around about the current state.\n * @param {Parent & {children: Array<FlowContent>}} parent\n *   Parent of flow nodes.\n * @param {TrackFields} info\n *   Info on where we are in the document we are generating.\n * @returns {string}\n *   Serialized children, joined by (blank) lines.\n */\nfunction containerFlowBound(parent, info) {\n  return containerFlow(parent, this, info)\n}\n\n/**\n * Make a string safe for embedding in markdown constructs.\n *\n * In markdown, almost all punctuation characters can, in certain cases,\n * result in something.\n * Whether they do is highly subjective to where they happen and in what\n * they happen.\n *\n * To solve this, `mdast-util-to-markdown` tracks:\n *\n * * Characters before and after something;\n * * What “constructs” we are in.\n *\n * This information is then used by this function to escape or encode\n * special characters.\n *\n * @this {State}\n *   Info passed around about the current state.\n * @param {string | null | undefined} value\n *   Raw value to make safe.\n * @param {SafeConfig} config\n *   Configuration.\n * @returns {string}\n *   Serialized markdown safe for embedding.\n */\nfunction safeBound(value, config) {\n  return safe(this, value, config)\n}\n","/**\n * @typedef {import('mdast').Root|import('mdast').Content} Node\n * @typedef {import('mdast-util-to-markdown').Options} ToMarkdownOptions\n * @typedef {Omit<ToMarkdownOptions, 'extensions'>} Options\n */\n\nimport {toMarkdown} from 'mdast-util-to-markdown'\n\n/**\n * @this {import('unified').Processor}\n * @type {import('unified').Plugin<[Options?]|void[], Node, string>}\n */\nexport default function remarkStringify(options) {\n  /** @type {import('unified').CompilerFunction<Node, string>} */\n  const compiler = (tree) => {\n    // Assume options.\n    const settings = /** @type {Options} */ (this.data('settings'))\n\n    return toMarkdown(\n      tree,\n      Object.assign({}, settings, options, {\n        // Note: this option is not in the readme.\n        // The goal is for it to be set by plugins on `data` instead of being\n        // passed by users.\n        extensions:\n          /** @type {ToMarkdownOptions['extensions']} */ (\n            this.data('toMarkdownExtensions')\n          ) || []\n      })\n    )\n  }\n\n  Object.assign(this, {Compiler: compiler})\n}\n"],"names":["element","document","createElement","decodeNamedCharacterReference","value","characterReference","innerHTML","char","textContent","charCodeAt","length","convert","test","undefined","ok","check","castFactory","type","node","typeFactory","Array","isArray","tests","checks","index","any","_len","arguments","parameters","_key","call","this","anyFactory","all","key","propsFactory","Error","_len2","_key2","Boolean","phrasing","inlineCode","_","state","sequence","RegExp","unsafe","pattern","expression","patternCompile","match","atBreak","exec","position","slice","peek","listItem","parent","info","listItemIndent","style","options","checkListItemIndent","bullet","bulletCurrent","checkBullet","ordered","start","incrementListMarker","children","indexOf","size","spread","Math","ceil","tracker","createTracker","move","repeat","shift","exit","enter","indentLines","containerFlow","current","line","blank","association","label","identifier","decodeString","marker","indexStack","results","push","child","handle","_objectSpread","before","after","bulletLastUsed","between","pop","join","left","right","result","containerPhrasing","handlers","charAt","replace","eol","map","one","_compiled","character","patternInScope","stack","listInScope","inConstruct","notInConstruct","list","none","includes","safe","input","config","positions","infos","sort","numerical","end","escapeBackslashes","encode","toString","toUpperCase","a","b","whole","track","now","lineShift","column","chunks","split","tail","emptyOptions","settings","includeImageAlt","includeHtml","alt","values","decodeNumericCharacterReference","base","code","Number","parseInt","String","fromCharCode","characterEscapeOrReference","decode","$0","$1","$2","head","hex","configure","extension","extensions","Object","assign","hardBreak","_1","formatCodeAsIndented","fences","lang","checkQuote","quote","emphasis","checkEmphasis","formatHeadingAsSetext","literalWithBreak","visit","EXIT","depth","setext","html","image","suffix","subexit","url","title","concat","imageReference","referenceType","reference","associationId","formatLinkAsAutolink","raw","resourceLink","link","linkReference","text","checkBulletOrdered","bulletOrdered","checkRule","rule","strong","checkStrong","blockquote","break","fence","checkFence","max","substring","source","expected","count","TypeError","longestStreak","meta","definition","heading","rank","min","lastIndexOf","closeAtx","bulletOther","bulletOrderedOther","checkBulletOrderedOther","checkBulletOther","useDifferentMarker","firstListItem","item","paragraph","root","some","d","thematicBreak","ruleSpaces","repetition","ruleRepetition","checkRuleRepetition","fullPhrasingSpans","invalid","unknown","joinDefinition","containerPhrasingBound","containerFlowBound","safeBound","remarkStringify","Compiler","tree","data","name","tightDefinitions","zwitch","toMarkdown"],"sourceRoot":""}