{"version":3,"file":"static/js/1504.ca655bbc.chunk.js","mappings":"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","sources":["../node_modules/extend/index.js","../node_modules/is-buffer/index.js","../node_modules/bail/index.js","../node_modules/is-plain-obj/index.js","../node_modules/trough/lib/index.js","../node_modules/vfile-message/lib/index.js","../node_modules/vfile/lib/minpath.browser.js","../node_modules/vfile/lib/minproc.browser.js","../node_modules/vfile/lib/minurl.shared.js","../node_modules/vfile/lib/minurl.browser.js","../node_modules/vfile/lib/index.js","../node_modules/unified/lib/index.js","../node_modules/unist-util-stringify-position/lib/index.js"],"sourcesContent":["'use strict';\n\nvar hasOwn = Object.prototype.hasOwnProperty;\nvar toStr = Object.prototype.toString;\nvar defineProperty = Object.defineProperty;\nvar gOPD = Object.getOwnPropertyDescriptor;\n\nvar isArray = function isArray(arr) {\n\tif (typeof Array.isArray === 'function') {\n\t\treturn Array.isArray(arr);\n\t}\n\n\treturn toStr.call(arr) === '[object Array]';\n};\n\nvar isPlainObject = function isPlainObject(obj) {\n\tif (!obj || toStr.call(obj) !== '[object Object]') {\n\t\treturn false;\n\t}\n\n\tvar hasOwnConstructor = hasOwn.call(obj, 'constructor');\n\tvar hasIsPrototypeOf = obj.constructor && obj.constructor.prototype && hasOwn.call(obj.constructor.prototype, 'isPrototypeOf');\n\t// Not own constructor property must be Object\n\tif (obj.constructor && !hasOwnConstructor && !hasIsPrototypeOf) {\n\t\treturn false;\n\t}\n\n\t// Own properties are enumerated firstly, so to speed up,\n\t// if last one is own, then all properties are own.\n\tvar key;\n\tfor (key in obj) { /**/ }\n\n\treturn typeof key === 'undefined' || hasOwn.call(obj, key);\n};\n\n// If name is '__proto__', and Object.defineProperty is available, define __proto__ as an own property on target\nvar setProperty = function setProperty(target, options) {\n\tif (defineProperty && options.name === '__proto__') {\n\t\tdefineProperty(target, options.name, {\n\t\t\tenumerable: true,\n\t\t\tconfigurable: true,\n\t\t\tvalue: options.newValue,\n\t\t\twritable: true\n\t\t});\n\t} else {\n\t\ttarget[options.name] = options.newValue;\n\t}\n};\n\n// Return undefined instead of __proto__ if '__proto__' is not an own property\nvar getProperty = function getProperty(obj, name) {\n\tif (name === '__proto__') {\n\t\tif (!hasOwn.call(obj, name)) {\n\t\t\treturn void 0;\n\t\t} else if (gOPD) {\n\t\t\t// In early versions of node, obj['__proto__'] is buggy when obj has\n\t\t\t// __proto__ as an own property. Object.getOwnPropertyDescriptor() works.\n\t\t\treturn gOPD(obj, name).value;\n\t\t}\n\t}\n\n\treturn obj[name];\n};\n\nmodule.exports = function extend() {\n\tvar options, name, src, copy, copyIsArray, clone;\n\tvar target = arguments[0];\n\tvar i = 1;\n\tvar length = arguments.length;\n\tvar deep = false;\n\n\t// Handle a deep copy situation\n\tif (typeof target === 'boolean') {\n\t\tdeep = target;\n\t\ttarget = arguments[1] || {};\n\t\t// skip the boolean and the target\n\t\ti = 2;\n\t}\n\tif (target == null || (typeof target !== 'object' && typeof target !== 'function')) {\n\t\ttarget = {};\n\t}\n\n\tfor (; i < length; ++i) {\n\t\toptions = arguments[i];\n\t\t// Only deal with non-null/undefined values\n\t\tif (options != null) {\n\t\t\t// Extend the base object\n\t\t\tfor (name in options) {\n\t\t\t\tsrc = getProperty(target, name);\n\t\t\t\tcopy = getProperty(options, name);\n\n\t\t\t\t// Prevent never-ending loop\n\t\t\t\tif (target !== copy) {\n\t\t\t\t\t// Recurse if we're merging plain objects or arrays\n\t\t\t\t\tif (deep && copy && (isPlainObject(copy) || (copyIsArray = isArray(copy)))) {\n\t\t\t\t\t\tif (copyIsArray) {\n\t\t\t\t\t\t\tcopyIsArray = false;\n\t\t\t\t\t\t\tclone = src && isArray(src) ? src : [];\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tclone = src && isPlainObject(src) ? src : {};\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Never move original objects, clone them\n\t\t\t\t\t\tsetProperty(target, { name: name, newValue: extend(deep, clone, copy) });\n\n\t\t\t\t\t// Don't bring in undefined values\n\t\t\t\t\t} else if (typeof copy !== 'undefined') {\n\t\t\t\t\t\tsetProperty(target, { name: name, newValue: copy });\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// Return the modified object\n\treturn target;\n};\n","/*!\n * Determine if an object is a Buffer\n *\n * @author   Feross Aboukhadijeh <https://feross.org>\n * @license  MIT\n */\n\nmodule.exports = function isBuffer (obj) {\n  return obj != null && obj.constructor != null &&\n    typeof obj.constructor.isBuffer === 'function' && obj.constructor.isBuffer(obj)\n}\n","/**\n * Throw a given error.\n *\n * @param {Error|null|undefined} [error]\n *   Maybe error.\n * @returns {asserts error is null|undefined}\n */\nexport function bail(error) {\n  if (error) {\n    throw error\n  }\n}\n","export default function isPlainObject(value) {\n\tif (typeof value !== 'object' || value === null) {\n\t\treturn false;\n\t}\n\n\tconst prototype = Object.getPrototypeOf(value);\n\treturn (prototype === null || prototype === Object.prototype || Object.getPrototypeOf(prototype) === null) && !(Symbol.toStringTag in value) && !(Symbol.iterator in value);\n}\n","// To do: remove `void`s\n// To do: remove `null` from output of our APIs, allow it as user APIs.\n\n/**\n * @typedef {(error?: Error | null | undefined, ...output: Array<any>) => void} Callback\n *   Callback.\n *\n * @typedef {(...input: Array<any>) => any} Middleware\n *   Ware.\n *\n * @typedef Pipeline\n *   Pipeline.\n * @property {Run} run\n *   Run the pipeline.\n * @property {Use} use\n *   Add middleware.\n *\n * @typedef {(...input: Array<any>) => void} Run\n *   Call all middleware.\n *\n *   Calls `done` on completion with either an error or the output of the\n *   last middleware.\n *\n *   > 👉 **Note**: as the length of input defines whether async functions get a\n *   > `next` function,\n *   > it’s recommended to keep `input` at one value normally.\n\n *\n * @typedef {(fn: Middleware) => Pipeline} Use\n *   Add middleware.\n */\n\n/**\n * Create new middleware.\n *\n * @returns {Pipeline}\n *   Pipeline.\n */\nexport function trough() {\n  /** @type {Array<Middleware>} */\n  const fns = []\n  /** @type {Pipeline} */\n  const pipeline = {run, use}\n\n  return pipeline\n\n  /** @type {Run} */\n  function run(...values) {\n    let middlewareIndex = -1\n    /** @type {Callback} */\n    const callback = values.pop()\n\n    if (typeof callback !== 'function') {\n      throw new TypeError('Expected function as last argument, not ' + callback)\n    }\n\n    next(null, ...values)\n\n    /**\n     * Run the next `fn`, or we’re done.\n     *\n     * @param {Error | null | undefined} error\n     * @param {Array<any>} output\n     */\n    function next(error, ...output) {\n      const fn = fns[++middlewareIndex]\n      let index = -1\n\n      if (error) {\n        callback(error)\n        return\n      }\n\n      // Copy non-nullish input into values.\n      while (++index < values.length) {\n        if (output[index] === null || output[index] === undefined) {\n          output[index] = values[index]\n        }\n      }\n\n      // Save the newly created `output` for the next call.\n      values = output\n\n      // Next or done.\n      if (fn) {\n        wrap(fn, next)(...output)\n      } else {\n        callback(null, ...output)\n      }\n    }\n  }\n\n  /** @type {Use} */\n  function use(middelware) {\n    if (typeof middelware !== 'function') {\n      throw new TypeError(\n        'Expected `middelware` to be a function, not ' + middelware\n      )\n    }\n\n    fns.push(middelware)\n    return pipeline\n  }\n}\n\n/**\n * Wrap `middleware` into a uniform interface.\n *\n * You can pass all input to the resulting function.\n * `callback` is then called with the output of `middleware`.\n *\n * If `middleware` accepts more arguments than the later given in input,\n * an extra `done` function is passed to it after that input,\n * which must be called by `middleware`.\n *\n * The first value in `input` is the main input value.\n * All other input values are the rest input values.\n * The values given to `callback` are the input values,\n * merged with every non-nullish output value.\n *\n * * if `middleware` throws an error,\n *   returns a promise that is rejected,\n *   or calls the given `done` function with an error,\n *   `callback` is called with that error\n * * if `middleware` returns a value or returns a promise that is resolved,\n *   that value is the main output value\n * * if `middleware` calls `done`,\n *   all non-nullish values except for the first one (the error) overwrite the\n *   output values\n *\n * @param {Middleware} middleware\n *   Function to wrap.\n * @param {Callback} callback\n *   Callback called with the output of `middleware`.\n * @returns {Run}\n *   Wrapped middleware.\n */\nexport function wrap(middleware, callback) {\n  /** @type {boolean} */\n  let called\n\n  return wrapped\n\n  /**\n   * Call `middleware`.\n   * @this {any}\n   * @param {Array<any>} parameters\n   * @returns {void}\n   */\n  function wrapped(...parameters) {\n    const fnExpectsCallback = middleware.length > parameters.length\n    /** @type {any} */\n    let result\n\n    if (fnExpectsCallback) {\n      parameters.push(done)\n    }\n\n    try {\n      result = middleware.apply(this, parameters)\n    } catch (error) {\n      const exception = /** @type {Error} */ (error)\n\n      // Well, this is quite the pickle.\n      // `middleware` received a callback and called it synchronously, but that\n      // threw an error.\n      // The only thing left to do is to throw the thing instead.\n      if (fnExpectsCallback && called) {\n        throw exception\n      }\n\n      return done(exception)\n    }\n\n    if (!fnExpectsCallback) {\n      if (result && result.then && typeof result.then === 'function') {\n        result.then(then, done)\n      } else if (result instanceof Error) {\n        done(result)\n      } else {\n        then(result)\n      }\n    }\n  }\n\n  /**\n   * Call `callback`, only once.\n   *\n   * @type {Callback}\n   */\n  function done(error, ...output) {\n    if (!called) {\n      called = true\n      callback(error, ...output)\n    }\n  }\n\n  /**\n   * Call `done` with one value.\n   *\n   * @param {any} [value]\n   */\n  function then(value) {\n    done(null, value)\n  }\n}\n","/**\n * @typedef {import('unist').Node} Node\n * @typedef {import('unist').Position} Position\n * @typedef {import('unist').Point} Point\n * @typedef {object & {type: string, position?: Position | undefined}} NodeLike\n */\n\nimport {stringifyPosition} from 'unist-util-stringify-position'\n\n/**\n * Message.\n */\nexport class VFileMessage extends Error {\n  /**\n   * Create a message for `reason` at `place` from `origin`.\n   *\n   * When an error is passed in as `reason`, the `stack` is copied.\n   *\n   * @param {string | Error | VFileMessage} reason\n   *   Reason for message, uses the stack and message of the error if given.\n   *\n   *   > 👉 **Note**: you should use markdown.\n   * @param {Node | NodeLike | Position | Point | null | undefined} [place]\n   *   Place in file where the message occurred.\n   * @param {string | null | undefined} [origin]\n   *   Place in code where the message originates (example:\n   *   `'my-package:my-rule'` or `'my-rule'`).\n   * @returns\n   *   Instance of `VFileMessage`.\n   */\n  // To do: next major: expose `undefined` everywhere instead of `null`.\n  constructor(reason, place, origin) {\n    /** @type {[string | null, string | null]} */\n    const parts = [null, null]\n    /** @type {Position} */\n    let position = {\n      // @ts-expect-error: we always follows the structure of `position`.\n      start: {line: null, column: null},\n      // @ts-expect-error: \"\n      end: {line: null, column: null}\n    }\n\n    super()\n\n    if (typeof place === 'string') {\n      origin = place\n      place = undefined\n    }\n\n    if (typeof origin === 'string') {\n      const index = origin.indexOf(':')\n\n      if (index === -1) {\n        parts[1] = origin\n      } else {\n        parts[0] = origin.slice(0, index)\n        parts[1] = origin.slice(index + 1)\n      }\n    }\n\n    if (place) {\n      // Node.\n      if ('type' in place || 'position' in place) {\n        if (place.position) {\n          // To do: next major: deep clone.\n          // @ts-expect-error: looks like a position.\n          position = place.position\n        }\n      }\n      // Position.\n      else if ('start' in place || 'end' in place) {\n        // @ts-expect-error: looks like a position.\n        // To do: next major: deep clone.\n        position = place\n      }\n      // Point.\n      else if ('line' in place || 'column' in place) {\n        // To do: next major: deep clone.\n        position.start = place\n      }\n    }\n\n    // Fields from `Error`.\n    /**\n     * Serialized positional info of error.\n     *\n     * On normal errors, this would be something like `ParseError`, buit in\n     * `VFile` messages we use this space to show where an error happened.\n     */\n    this.name = stringifyPosition(place) || '1:1'\n\n    /**\n     * Reason for message.\n     *\n     * @type {string}\n     */\n    this.message = typeof reason === 'object' ? reason.message : reason\n\n    /**\n     * Stack of message.\n     *\n     * This is used by normal errors to show where something happened in\n     * programming code, irrelevant for `VFile` messages,\n     *\n     * @type {string}\n     */\n    this.stack = ''\n\n    if (typeof reason === 'object' && reason.stack) {\n      this.stack = reason.stack\n    }\n\n    /**\n     * Reason for message.\n     *\n     * > 👉 **Note**: you should use markdown.\n     *\n     * @type {string}\n     */\n    this.reason = this.message\n\n    /* eslint-disable no-unused-expressions */\n    /**\n     * State of problem.\n     *\n     * * `true` — marks associated file as no longer processable (error)\n     * * `false` — necessitates a (potential) change (warning)\n     * * `null | undefined` — for things that might not need changing (info)\n     *\n     * @type {boolean | null | undefined}\n     */\n    this.fatal\n\n    /**\n     * Starting line of error.\n     *\n     * @type {number | null}\n     */\n    this.line = position.start.line\n\n    /**\n     * Starting column of error.\n     *\n     * @type {number | null}\n     */\n    this.column = position.start.column\n\n    /**\n     * Full unist position.\n     *\n     * @type {Position | null}\n     */\n    this.position = position\n\n    /**\n     * Namespace of message (example: `'my-package'`).\n     *\n     * @type {string | null}\n     */\n    this.source = parts[0]\n\n    /**\n     * Category of message (example: `'my-rule'`).\n     *\n     * @type {string | null}\n     */\n    this.ruleId = parts[1]\n\n    /**\n     * Path of a file (used throughout the `VFile` ecosystem).\n     *\n     * @type {string | null}\n     */\n    this.file\n\n    // The following fields are “well known”.\n    // Not standard.\n    // Feel free to add other non-standard fields to your messages.\n\n    /**\n     * Specify the source value that’s being reported, which is deemed\n     * incorrect.\n     *\n     * @type {string | null}\n     */\n    this.actual\n\n    /**\n     * Suggest acceptable values that can be used instead of `actual`.\n     *\n     * @type {Array<string> | null}\n     */\n    this.expected\n\n    /**\n     * Link to docs for the message.\n     *\n     * > 👉 **Note**: this must be an absolute URL that can be passed as `x`\n     * > to `new URL(x)`.\n     *\n     * @type {string | null}\n     */\n    this.url\n\n    /**\n     * Long form description of the message (you should use markdown).\n     *\n     * @type {string | null}\n     */\n    this.note\n    /* eslint-enable no-unused-expressions */\n  }\n}\n\nVFileMessage.prototype.file = ''\nVFileMessage.prototype.name = ''\nVFileMessage.prototype.reason = ''\nVFileMessage.prototype.message = ''\nVFileMessage.prototype.stack = ''\nVFileMessage.prototype.fatal = null\nVFileMessage.prototype.column = null\nVFileMessage.prototype.line = null\nVFileMessage.prototype.source = null\nVFileMessage.prototype.ruleId = null\nVFileMessage.prototype.position = null\n","// A derivative work based on:\n// <https://github.com/browserify/path-browserify>.\n// Which is licensed:\n//\n// MIT License\n//\n// Copyright (c) 2013 James Halliday\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy of\n// this software and associated documentation files (the \"Software\"), to deal in\n// the Software without restriction, including without limitation the rights to\n// use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of\n// the Software, and to permit persons to whom the Software is furnished to do so,\n// subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in all\n// copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS\n// FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR\n// COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER\n// IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n// CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n// A derivative work based on:\n//\n// Parts of that are extracted from Node’s internal `path` module:\n// <https://github.com/nodejs/node/blob/master/lib/path.js>.\n// Which is licensed:\n//\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nexport const path = {basename, dirname, extname, join, sep: '/'}\n\n/* eslint-disable max-depth, complexity */\n\n/**\n * Get the basename from a path.\n *\n * @param {string} path\n *   File path.\n * @param {string | undefined} [ext]\n *   Extension to strip.\n * @returns {string}\n *   Stem or basename.\n */\nfunction basename(path, ext) {\n  if (ext !== undefined && typeof ext !== 'string') {\n    throw new TypeError('\"ext\" argument must be a string')\n  }\n\n  assertPath(path)\n  let start = 0\n  let end = -1\n  let index = path.length\n  /** @type {boolean | undefined} */\n  let seenNonSlash\n\n  if (ext === undefined || ext.length === 0 || ext.length > path.length) {\n    while (index--) {\n      if (path.charCodeAt(index) === 47 /* `/` */) {\n        // If we reached a path separator that was not part of a set of path\n        // separators at the end of the string, stop now.\n        if (seenNonSlash) {\n          start = index + 1\n          break\n        }\n      } else if (end < 0) {\n        // We saw the first non-path separator, mark this as the end of our\n        // path component.\n        seenNonSlash = true\n        end = index + 1\n      }\n    }\n\n    return end < 0 ? '' : path.slice(start, end)\n  }\n\n  if (ext === path) {\n    return ''\n  }\n\n  let firstNonSlashEnd = -1\n  let extIndex = ext.length - 1\n\n  while (index--) {\n    if (path.charCodeAt(index) === 47 /* `/` */) {\n      // If we reached a path separator that was not part of a set of path\n      // separators at the end of the string, stop now.\n      if (seenNonSlash) {\n        start = index + 1\n        break\n      }\n    } else {\n      if (firstNonSlashEnd < 0) {\n        // We saw the first non-path separator, remember this index in case\n        // we need it if the extension ends up not matching.\n        seenNonSlash = true\n        firstNonSlashEnd = index + 1\n      }\n\n      if (extIndex > -1) {\n        // Try to match the explicit extension.\n        if (path.charCodeAt(index) === ext.charCodeAt(extIndex--)) {\n          if (extIndex < 0) {\n            // We matched the extension, so mark this as the end of our path\n            // component\n            end = index\n          }\n        } else {\n          // Extension does not match, so our result is the entire path\n          // component\n          extIndex = -1\n          end = firstNonSlashEnd\n        }\n      }\n    }\n  }\n\n  if (start === end) {\n    end = firstNonSlashEnd\n  } else if (end < 0) {\n    end = path.length\n  }\n\n  return path.slice(start, end)\n}\n\n/**\n * Get the dirname from a path.\n *\n * @param {string} path\n *   File path.\n * @returns {string}\n *   File path.\n */\nfunction dirname(path) {\n  assertPath(path)\n\n  if (path.length === 0) {\n    return '.'\n  }\n\n  let end = -1\n  let index = path.length\n  /** @type {boolean | undefined} */\n  let unmatchedSlash\n\n  // Prefix `--` is important to not run on `0`.\n  while (--index) {\n    if (path.charCodeAt(index) === 47 /* `/` */) {\n      if (unmatchedSlash) {\n        end = index\n        break\n      }\n    } else if (!unmatchedSlash) {\n      // We saw the first non-path separator\n      unmatchedSlash = true\n    }\n  }\n\n  return end < 0\n    ? path.charCodeAt(0) === 47 /* `/` */\n      ? '/'\n      : '.'\n    : end === 1 && path.charCodeAt(0) === 47 /* `/` */\n    ? '//'\n    : path.slice(0, end)\n}\n\n/**\n * Get an extname from a path.\n *\n * @param {string} path\n *   File path.\n * @returns {string}\n *   Extname.\n */\nfunction extname(path) {\n  assertPath(path)\n\n  let index = path.length\n\n  let end = -1\n  let startPart = 0\n  let startDot = -1\n  // Track the state of characters (if any) we see before our first dot and\n  // after any path separator we find.\n  let preDotState = 0\n  /** @type {boolean | undefined} */\n  let unmatchedSlash\n\n  while (index--) {\n    const code = path.charCodeAt(index)\n\n    if (code === 47 /* `/` */) {\n      // If we reached a path separator that was not part of a set of path\n      // separators at the end of the string, stop now.\n      if (unmatchedSlash) {\n        startPart = index + 1\n        break\n      }\n\n      continue\n    }\n\n    if (end < 0) {\n      // We saw the first non-path separator, mark this as the end of our\n      // extension.\n      unmatchedSlash = true\n      end = index + 1\n    }\n\n    if (code === 46 /* `.` */) {\n      // If this is our first dot, mark it as the start of our extension.\n      if (startDot < 0) {\n        startDot = index\n      } else if (preDotState !== 1) {\n        preDotState = 1\n      }\n    } else if (startDot > -1) {\n      // We saw a non-dot and non-path separator before our dot, so we should\n      // have a good chance at having a non-empty extension.\n      preDotState = -1\n    }\n  }\n\n  if (\n    startDot < 0 ||\n    end < 0 ||\n    // We saw a non-dot character immediately before the dot.\n    preDotState === 0 ||\n    // The (right-most) trimmed path component is exactly `..`.\n    (preDotState === 1 && startDot === end - 1 && startDot === startPart + 1)\n  ) {\n    return ''\n  }\n\n  return path.slice(startDot, end)\n}\n\n/**\n * Join segments from a path.\n *\n * @param {Array<string>} segments\n *   Path segments.\n * @returns {string}\n *   File path.\n */\nfunction join(...segments) {\n  let index = -1\n  /** @type {string | undefined} */\n  let joined\n\n  while (++index < segments.length) {\n    assertPath(segments[index])\n\n    if (segments[index]) {\n      joined =\n        joined === undefined ? segments[index] : joined + '/' + segments[index]\n    }\n  }\n\n  return joined === undefined ? '.' : normalize(joined)\n}\n\n/**\n * Normalize a basic file path.\n *\n * @param {string} path\n *   File path.\n * @returns {string}\n *   File path.\n */\n// Note: `normalize` is not exposed as `path.normalize`, so some code is\n// manually removed from it.\nfunction normalize(path) {\n  assertPath(path)\n\n  const absolute = path.charCodeAt(0) === 47 /* `/` */\n\n  // Normalize the path according to POSIX rules.\n  let value = normalizeString(path, !absolute)\n\n  if (value.length === 0 && !absolute) {\n    value = '.'\n  }\n\n  if (value.length > 0 && path.charCodeAt(path.length - 1) === 47 /* / */) {\n    value += '/'\n  }\n\n  return absolute ? '/' + value : value\n}\n\n/**\n * Resolve `.` and `..` elements in a path with directory names.\n *\n * @param {string} path\n *   File path.\n * @param {boolean} allowAboveRoot\n *   Whether `..` can move above root.\n * @returns {string}\n *   File path.\n */\nfunction normalizeString(path, allowAboveRoot) {\n  let result = ''\n  let lastSegmentLength = 0\n  let lastSlash = -1\n  let dots = 0\n  let index = -1\n  /** @type {number | undefined} */\n  let code\n  /** @type {number} */\n  let lastSlashIndex\n\n  while (++index <= path.length) {\n    if (index < path.length) {\n      code = path.charCodeAt(index)\n    } else if (code === 47 /* `/` */) {\n      break\n    } else {\n      code = 47 /* `/` */\n    }\n\n    if (code === 47 /* `/` */) {\n      if (lastSlash === index - 1 || dots === 1) {\n        // Empty.\n      } else if (lastSlash !== index - 1 && dots === 2) {\n        if (\n          result.length < 2 ||\n          lastSegmentLength !== 2 ||\n          result.charCodeAt(result.length - 1) !== 46 /* `.` */ ||\n          result.charCodeAt(result.length - 2) !== 46 /* `.` */\n        ) {\n          if (result.length > 2) {\n            lastSlashIndex = result.lastIndexOf('/')\n\n            if (lastSlashIndex !== result.length - 1) {\n              if (lastSlashIndex < 0) {\n                result = ''\n                lastSegmentLength = 0\n              } else {\n                result = result.slice(0, lastSlashIndex)\n                lastSegmentLength = result.length - 1 - result.lastIndexOf('/')\n              }\n\n              lastSlash = index\n              dots = 0\n              continue\n            }\n          } else if (result.length > 0) {\n            result = ''\n            lastSegmentLength = 0\n            lastSlash = index\n            dots = 0\n            continue\n          }\n        }\n\n        if (allowAboveRoot) {\n          result = result.length > 0 ? result + '/..' : '..'\n          lastSegmentLength = 2\n        }\n      } else {\n        if (result.length > 0) {\n          result += '/' + path.slice(lastSlash + 1, index)\n        } else {\n          result = path.slice(lastSlash + 1, index)\n        }\n\n        lastSegmentLength = index - lastSlash - 1\n      }\n\n      lastSlash = index\n      dots = 0\n    } else if (code === 46 /* `.` */ && dots > -1) {\n      dots++\n    } else {\n      dots = -1\n    }\n  }\n\n  return result\n}\n\n/**\n * Make sure `path` is a string.\n *\n * @param {string} path\n *   File path.\n * @returns {asserts path is string}\n *   Nothing.\n */\nfunction assertPath(path) {\n  if (typeof path !== 'string') {\n    throw new TypeError(\n      'Path must be a string. Received ' + JSON.stringify(path)\n    )\n  }\n}\n\n/* eslint-enable max-depth, complexity */\n","// Somewhat based on:\n// <https://github.com/defunctzombie/node-process/blob/master/browser.js>.\n// But I don’t think one tiny line of code can be copyrighted. 😅\nexport const proc = {cwd}\n\nfunction cwd() {\n  return '/'\n}\n","/**\n * @typedef URL\n * @property {string} hash\n * @property {string} host\n * @property {string} hostname\n * @property {string} href\n * @property {string} origin\n * @property {string} password\n * @property {string} pathname\n * @property {string} port\n * @property {string} protocol\n * @property {string} search\n * @property {any} searchParams\n * @property {string} username\n * @property {() => string} toString\n * @property {() => string} toJSON\n */\n\n/**\n * Check if `fileUrlOrPath` looks like a URL.\n *\n * @param {unknown} fileUrlOrPath\n *   File path or URL.\n * @returns {fileUrlOrPath is URL}\n *   Whether it’s a URL.\n */\n// From: <https://github.com/nodejs/node/blob/fcf8ba4/lib/internal/url.js#L1501>\nexport function isUrl(fileUrlOrPath) {\n  return (\n    fileUrlOrPath !== null &&\n    typeof fileUrlOrPath === 'object' &&\n    // @ts-expect-error: indexable.\n    fileUrlOrPath.href &&\n    // @ts-expect-error: indexable.\n    fileUrlOrPath.origin\n  )\n}\n","/// <reference lib=\"dom\" />\n\nimport {isUrl} from './minurl.shared.js'\n\n// See: <https://github.com/nodejs/node/blob/fcf8ba4/lib/internal/url.js>\n\n/**\n * @param {string | URL} path\n *   File URL.\n * @returns {string}\n *   File URL.\n */\nexport function urlToPath(path) {\n  if (typeof path === 'string') {\n    path = new URL(path)\n  } else if (!isUrl(path)) {\n    /** @type {NodeJS.ErrnoException} */\n    const error = new TypeError(\n      'The \"path\" argument must be of type string or an instance of URL. Received `' +\n        path +\n        '`'\n    )\n    error.code = 'ERR_INVALID_ARG_TYPE'\n    throw error\n  }\n\n  if (path.protocol !== 'file:') {\n    /** @type {NodeJS.ErrnoException} */\n    const error = new TypeError('The URL must be of scheme file')\n    error.code = 'ERR_INVALID_URL_SCHEME'\n    throw error\n  }\n\n  return getPathFromURLPosix(path)\n}\n\n/**\n * Get a path from a POSIX URL.\n *\n * @param {URL} url\n *   URL.\n * @returns {string}\n *   File path.\n */\nfunction getPathFromURLPosix(url) {\n  if (url.hostname !== '') {\n    /** @type {NodeJS.ErrnoException} */\n    const error = new TypeError(\n      'File URL host must be \"localhost\" or empty on darwin'\n    )\n    error.code = 'ERR_INVALID_FILE_URL_HOST'\n    throw error\n  }\n\n  const pathname = url.pathname\n  let index = -1\n\n  while (++index < pathname.length) {\n    if (\n      pathname.charCodeAt(index) === 37 /* `%` */ &&\n      pathname.charCodeAt(index + 1) === 50 /* `2` */\n    ) {\n      const third = pathname.charCodeAt(index + 2)\n      if (third === 70 /* `F` */ || third === 102 /* `f` */) {\n        /** @type {NodeJS.ErrnoException} */\n        const error = new TypeError(\n          'File URL path must not include encoded / characters'\n        )\n        error.code = 'ERR_INVALID_FILE_URL_PATH'\n        throw error\n      }\n    }\n  }\n\n  return decodeURIComponent(pathname)\n}\n\nexport {isUrl} from './minurl.shared.js'\n","/**\n * @typedef {import('unist').Node} Node\n * @typedef {import('unist').Position} Position\n * @typedef {import('unist').Point} Point\n * @typedef {import('./minurl.shared.js').URL} URL\n * @typedef {import('../index.js').Data} Data\n * @typedef {import('../index.js').Value} Value\n */\n\n/**\n * @typedef {Record<string, unknown> & {type: string, position?: Position | undefined}} NodeLike\n *\n * @typedef {'ascii' | 'utf8' | 'utf-8' | 'utf16le' | 'ucs2' | 'ucs-2' | 'base64' | 'base64url' | 'latin1' | 'binary' | 'hex'} BufferEncoding\n *   Encodings supported by the buffer class.\n *\n *   This is a copy of the types from Node, copied to prevent Node globals from\n *   being needed.\n *   Copied from: <https://github.com/DefinitelyTyped/DefinitelyTyped/blob/90a4ec8/types/node/buffer.d.ts#L170>\n *\n * @typedef {Options | URL | Value | VFile} Compatible\n *   Things that can be passed to the constructor.\n *\n * @typedef VFileCoreOptions\n *   Set multiple values.\n * @property {Value | null | undefined} [value]\n *   Set `value`.\n * @property {string | null | undefined} [cwd]\n *   Set `cwd`.\n * @property {Array<string> | null | undefined} [history]\n *   Set `history`.\n * @property {URL | string | null | undefined} [path]\n *   Set `path`.\n * @property {string | null | undefined} [basename]\n *   Set `basename`.\n * @property {string | null | undefined} [stem]\n *   Set `stem`.\n * @property {string | null | undefined} [extname]\n *   Set `extname`.\n * @property {string | null | undefined} [dirname]\n *   Set `dirname`.\n * @property {Data | null | undefined} [data]\n *   Set `data`.\n *\n * @typedef Map\n *   Raw source map.\n *\n *   See:\n *   <https://github.com/mozilla/source-map/blob/58819f0/source-map.d.ts#L15-L23>.\n * @property {number} version\n *   Which version of the source map spec this map is following.\n * @property {Array<string>} sources\n *   An array of URLs to the original source files.\n * @property {Array<string>} names\n *   An array of identifiers which can be referenced by individual mappings.\n * @property {string | undefined} [sourceRoot]\n *   The URL root from which all sources are relative.\n * @property {Array<string> | undefined} [sourcesContent]\n *   An array of contents of the original source files.\n * @property {string} mappings\n *   A string of base64 VLQs which contain the actual mappings.\n * @property {string} file\n *   The generated file this source map is associated with.\n *\n * @typedef {{[key: string]: unknown} & VFileCoreOptions} Options\n *   Configuration.\n *\n *   A bunch of keys that will be shallow copied over to the new file.\n *\n * @typedef {Record<string, unknown>} ReporterSettings\n *   Configuration for reporters.\n */\n\n/**\n * @template {ReporterSettings} Settings\n *   Options type.\n * @callback Reporter\n *   Type for a reporter.\n * @param {Array<VFile>} files\n *   Files to report.\n * @param {Settings} options\n *   Configuration.\n * @returns {string}\n *   Report.\n */\n\nimport bufferLike from 'is-buffer'\nimport {VFileMessage} from 'vfile-message'\nimport {path} from './minpath.js'\nimport {proc} from './minproc.js'\nimport {urlToPath, isUrl} from './minurl.js'\n\n/**\n * Order of setting (least specific to most), we need this because otherwise\n * `{stem: 'a', path: '~/b.js'}` would throw, as a path is needed before a\n * stem can be set.\n *\n * @type {Array<'basename' | 'dirname' | 'extname' | 'history' | 'path' | 'stem'>}\n */\nconst order = ['history', 'path', 'basename', 'stem', 'extname', 'dirname']\n\nexport class VFile {\n  /**\n   * Create a new virtual file.\n   *\n   * `options` is treated as:\n   *\n   * *   `string` or `Buffer` — `{value: options}`\n   * *   `URL` — `{path: options}`\n   * *   `VFile` — shallow copies its data over to the new file\n   * *   `object` — all fields are shallow copied over to the new file\n   *\n   * Path related fields are set in the following order (least specific to\n   * most specific): `history`, `path`, `basename`, `stem`, `extname`,\n   * `dirname`.\n   *\n   * You cannot set `dirname` or `extname` without setting either `history`,\n   * `path`, `basename`, or `stem` too.\n   *\n   * @param {Compatible | null | undefined} [value]\n   *   File value.\n   * @returns\n   *   New instance.\n   */\n  constructor(value) {\n    /** @type {Options | VFile} */\n    let options\n\n    if (!value) {\n      options = {}\n    } else if (typeof value === 'string' || buffer(value)) {\n      options = {value}\n    } else if (isUrl(value)) {\n      options = {path: value}\n    } else {\n      options = value\n    }\n\n    /**\n     * Place to store custom information (default: `{}`).\n     *\n     * It’s OK to store custom data directly on the file but moving it to\n     * `data` is recommended.\n     *\n     * @type {Data}\n     */\n    this.data = {}\n\n    /**\n     * List of messages associated with the file.\n     *\n     * @type {Array<VFileMessage>}\n     */\n    this.messages = []\n\n    /**\n     * List of filepaths the file moved between.\n     *\n     * The first is the original path and the last is the current path.\n     *\n     * @type {Array<string>}\n     */\n    this.history = []\n\n    /**\n     * Base of `path` (default: `process.cwd()` or `'/'` in browsers).\n     *\n     * @type {string}\n     */\n    this.cwd = proc.cwd()\n\n    /* eslint-disable no-unused-expressions */\n    /**\n     * Raw value.\n     *\n     * @type {Value}\n     */\n    this.value\n\n    // The below are non-standard, they are “well-known”.\n    // As in, used in several tools.\n\n    /**\n     * Whether a file was saved to disk.\n     *\n     * This is used by vfile reporters.\n     *\n     * @type {boolean}\n     */\n    this.stored\n\n    /**\n     * Custom, non-string, compiled, representation.\n     *\n     * This is used by unified to store non-string results.\n     * One example is when turning markdown into React nodes.\n     *\n     * @type {unknown}\n     */\n    this.result\n\n    /**\n     * Source map.\n     *\n     * This type is equivalent to the `RawSourceMap` type from the `source-map`\n     * module.\n     *\n     * @type {Map | null | undefined}\n     */\n    this.map\n    /* eslint-enable no-unused-expressions */\n\n    // Set path related properties in the correct order.\n    let index = -1\n\n    while (++index < order.length) {\n      const prop = order[index]\n\n      // Note: we specifically use `in` instead of `hasOwnProperty` to accept\n      // `vfile`s too.\n      if (\n        prop in options &&\n        options[prop] !== undefined &&\n        options[prop] !== null\n      ) {\n        // @ts-expect-error: TS doesn’t understand basic reality.\n        this[prop] = prop === 'history' ? [...options[prop]] : options[prop]\n      }\n    }\n\n    /** @type {string} */\n    let prop\n\n    // Set non-path related properties.\n    for (prop in options) {\n      // @ts-expect-error: fine to set other things.\n      if (!order.includes(prop)) {\n        // @ts-expect-error: fine to set other things.\n        this[prop] = options[prop]\n      }\n    }\n  }\n\n  /**\n   * Get the full path (example: `'~/index.min.js'`).\n   *\n   * @returns {string}\n   */\n  get path() {\n    return this.history[this.history.length - 1]\n  }\n\n  /**\n   * Set the full path (example: `'~/index.min.js'`).\n   *\n   * Cannot be nullified.\n   * You can set a file URL (a `URL` object with a `file:` protocol) which will\n   * be turned into a path with `url.fileURLToPath`.\n   *\n   * @param {string | URL} path\n   */\n  set path(path) {\n    if (isUrl(path)) {\n      path = urlToPath(path)\n    }\n\n    assertNonEmpty(path, 'path')\n\n    if (this.path !== path) {\n      this.history.push(path)\n    }\n  }\n\n  /**\n   * Get the parent path (example: `'~'`).\n   */\n  get dirname() {\n    return typeof this.path === 'string' ? path.dirname(this.path) : undefined\n  }\n\n  /**\n   * Set the parent path (example: `'~'`).\n   *\n   * Cannot be set if there’s no `path` yet.\n   */\n  set dirname(dirname) {\n    assertPath(this.basename, 'dirname')\n    this.path = path.join(dirname || '', this.basename)\n  }\n\n  /**\n   * Get the basename (including extname) (example: `'index.min.js'`).\n   */\n  get basename() {\n    return typeof this.path === 'string' ? path.basename(this.path) : undefined\n  }\n\n  /**\n   * Set basename (including extname) (`'index.min.js'`).\n   *\n   * Cannot contain path separators (`'/'` on unix, macOS, and browsers, `'\\'`\n   * on windows).\n   * Cannot be nullified (use `file.path = file.dirname` instead).\n   */\n  set basename(basename) {\n    assertNonEmpty(basename, 'basename')\n    assertPart(basename, 'basename')\n    this.path = path.join(this.dirname || '', basename)\n  }\n\n  /**\n   * Get the extname (including dot) (example: `'.js'`).\n   */\n  get extname() {\n    return typeof this.path === 'string' ? path.extname(this.path) : undefined\n  }\n\n  /**\n   * Set the extname (including dot) (example: `'.js'`).\n   *\n   * Cannot contain path separators (`'/'` on unix, macOS, and browsers, `'\\'`\n   * on windows).\n   * Cannot be set if there’s no `path` yet.\n   */\n  set extname(extname) {\n    assertPart(extname, 'extname')\n    assertPath(this.dirname, 'extname')\n\n    if (extname) {\n      if (extname.charCodeAt(0) !== 46 /* `.` */) {\n        throw new Error('`extname` must start with `.`')\n      }\n\n      if (extname.includes('.', 1)) {\n        throw new Error('`extname` cannot contain multiple dots')\n      }\n    }\n\n    this.path = path.join(this.dirname, this.stem + (extname || ''))\n  }\n\n  /**\n   * Get the stem (basename w/o extname) (example: `'index.min'`).\n   */\n  get stem() {\n    return typeof this.path === 'string'\n      ? path.basename(this.path, this.extname)\n      : undefined\n  }\n\n  /**\n   * Set the stem (basename w/o extname) (example: `'index.min'`).\n   *\n   * Cannot contain path separators (`'/'` on unix, macOS, and browsers, `'\\'`\n   * on windows).\n   * Cannot be nullified (use `file.path = file.dirname` instead).\n   */\n  set stem(stem) {\n    assertNonEmpty(stem, 'stem')\n    assertPart(stem, 'stem')\n    this.path = path.join(this.dirname || '', stem + (this.extname || ''))\n  }\n\n  /**\n   * Serialize the file.\n   *\n   * @param {BufferEncoding | null | undefined} [encoding='utf8']\n   *   Character encoding to understand `value` as when it’s a `Buffer`\n   *   (default: `'utf8'`).\n   * @returns {string}\n   *   Serialized file.\n   */\n  toString(encoding) {\n    return (this.value || '').toString(encoding || undefined)\n  }\n\n  /**\n   * Create a warning message associated with the file.\n   *\n   * Its `fatal` is set to `false` and `file` is set to the current file path.\n   * Its added to `file.messages`.\n   *\n   * @param {string | Error | VFileMessage} reason\n   *   Reason for message, uses the stack and message of the error if given.\n   * @param {Node | NodeLike | Position | Point | null | undefined} [place]\n   *   Place in file where the message occurred.\n   * @param {string | null | undefined} [origin]\n   *   Place in code where the message originates (example:\n   *   `'my-package:my-rule'` or `'my-rule'`).\n   * @returns {VFileMessage}\n   *   Message.\n   */\n  message(reason, place, origin) {\n    const message = new VFileMessage(reason, place, origin)\n\n    if (this.path) {\n      message.name = this.path + ':' + message.name\n      message.file = this.path\n    }\n\n    message.fatal = false\n\n    this.messages.push(message)\n\n    return message\n  }\n\n  /**\n   * Create an info message associated with the file.\n   *\n   * Its `fatal` is set to `null` and `file` is set to the current file path.\n   * Its added to `file.messages`.\n   *\n   * @param {string | Error | VFileMessage} reason\n   *   Reason for message, uses the stack and message of the error if given.\n   * @param {Node | NodeLike | Position | Point | null | undefined} [place]\n   *   Place in file where the message occurred.\n   * @param {string | null | undefined} [origin]\n   *   Place in code where the message originates (example:\n   *   `'my-package:my-rule'` or `'my-rule'`).\n   * @returns {VFileMessage}\n   *   Message.\n   */\n  info(reason, place, origin) {\n    const message = this.message(reason, place, origin)\n\n    message.fatal = null\n\n    return message\n  }\n\n  /**\n   * Create a fatal error associated with the file.\n   *\n   * Its `fatal` is set to `true` and `file` is set to the current file path.\n   * Its added to `file.messages`.\n   *\n   * > 👉 **Note**: a fatal error means that a file is no longer processable.\n   *\n   * @param {string | Error | VFileMessage} reason\n   *   Reason for message, uses the stack and message of the error if given.\n   * @param {Node | NodeLike | Position | Point | null | undefined} [place]\n   *   Place in file where the message occurred.\n   * @param {string | null | undefined} [origin]\n   *   Place in code where the message originates (example:\n   *   `'my-package:my-rule'` or `'my-rule'`).\n   * @returns {never}\n   *   Message.\n   * @throws {VFileMessage}\n   *   Message.\n   */\n  fail(reason, place, origin) {\n    const message = this.message(reason, place, origin)\n\n    message.fatal = true\n\n    throw message\n  }\n}\n\n/**\n * Assert that `part` is not a path (as in, does not contain `path.sep`).\n *\n * @param {string | null | undefined} part\n *   File path part.\n * @param {string} name\n *   Part name.\n * @returns {void}\n *   Nothing.\n */\nfunction assertPart(part, name) {\n  if (part && part.includes(path.sep)) {\n    throw new Error(\n      '`' + name + '` cannot be a path: did not expect `' + path.sep + '`'\n    )\n  }\n}\n\n/**\n * Assert that `part` is not empty.\n *\n * @param {string | undefined} part\n *   Thing.\n * @param {string} name\n *   Part name.\n * @returns {asserts part is string}\n *   Nothing.\n */\nfunction assertNonEmpty(part, name) {\n  if (!part) {\n    throw new Error('`' + name + '` cannot be empty')\n  }\n}\n\n/**\n * Assert `path` exists.\n *\n * @param {string | undefined} path\n *   Path.\n * @param {string} name\n *   Dependency name.\n * @returns {asserts path is string}\n *   Nothing.\n */\nfunction assertPath(path, name) {\n  if (!path) {\n    throw new Error('Setting `' + name + '` requires `path` to be set too')\n  }\n}\n\n/**\n * Assert `value` is a buffer.\n *\n * @param {unknown} value\n *   thing.\n * @returns {value is Buffer}\n *   Whether `value` is a Node.js buffer.\n */\nfunction buffer(value) {\n  return bufferLike(value)\n}\n","/**\n * @typedef {import('unist').Node} Node\n * @typedef {import('vfile').VFileCompatible} VFileCompatible\n * @typedef {import('vfile').VFileValue} VFileValue\n * @typedef {import('..').Processor} Processor\n * @typedef {import('..').Plugin} Plugin\n * @typedef {import('..').Preset} Preset\n * @typedef {import('..').Pluggable} Pluggable\n * @typedef {import('..').PluggableList} PluggableList\n * @typedef {import('..').Transformer} Transformer\n * @typedef {import('..').Parser} Parser\n * @typedef {import('..').Compiler} Compiler\n * @typedef {import('..').RunCallback} RunCallback\n * @typedef {import('..').ProcessCallback} ProcessCallback\n *\n * @typedef Context\n * @property {Node} tree\n * @property {VFile} file\n */\n\nimport {bail} from 'bail'\nimport isBuffer from 'is-buffer'\nimport extend from 'extend'\nimport isPlainObj from 'is-plain-obj'\nimport {trough} from 'trough'\nimport {VFile} from 'vfile'\n\n// Expose a frozen processor.\nexport const unified = base().freeze()\n\nconst own = {}.hasOwnProperty\n\n// Function to create the first processor.\n/**\n * @returns {Processor}\n */\nfunction base() {\n  const transformers = trough()\n  /** @type {Processor['attachers']} */\n  const attachers = []\n  /** @type {Record<string, unknown>} */\n  let namespace = {}\n  /** @type {boolean|undefined} */\n  let frozen\n  let freezeIndex = -1\n\n  // Data management.\n  // @ts-expect-error: overloads are handled.\n  processor.data = data\n  processor.Parser = undefined\n  processor.Compiler = undefined\n\n  // Lock.\n  processor.freeze = freeze\n\n  // Plugins.\n  processor.attachers = attachers\n  // @ts-expect-error: overloads are handled.\n  processor.use = use\n\n  // API.\n  processor.parse = parse\n  processor.stringify = stringify\n  // @ts-expect-error: overloads are handled.\n  processor.run = run\n  processor.runSync = runSync\n  // @ts-expect-error: overloads are handled.\n  processor.process = process\n  processor.processSync = processSync\n\n  // Expose.\n  return processor\n\n  // Create a new processor based on the processor in the current scope.\n  /** @type {Processor} */\n  function processor() {\n    const destination = base()\n    let index = -1\n\n    while (++index < attachers.length) {\n      destination.use(...attachers[index])\n    }\n\n    destination.data(extend(true, {}, namespace))\n\n    return destination\n  }\n\n  /**\n   * @param {string|Record<string, unknown>} [key]\n   * @param {unknown} [value]\n   * @returns {unknown}\n   */\n  function data(key, value) {\n    if (typeof key === 'string') {\n      // Set `key`.\n      if (arguments.length === 2) {\n        assertUnfrozen('data', frozen)\n        namespace[key] = value\n        return processor\n      }\n\n      // Get `key`.\n      return (own.call(namespace, key) && namespace[key]) || null\n    }\n\n    // Set space.\n    if (key) {\n      assertUnfrozen('data', frozen)\n      namespace = key\n      return processor\n    }\n\n    // Get space.\n    return namespace\n  }\n\n  /** @type {Processor['freeze']} */\n  function freeze() {\n    if (frozen) {\n      return processor\n    }\n\n    while (++freezeIndex < attachers.length) {\n      const [attacher, ...options] = attachers[freezeIndex]\n\n      if (options[0] === false) {\n        continue\n      }\n\n      if (options[0] === true) {\n        options[0] = undefined\n      }\n\n      /** @type {Transformer|void} */\n      const transformer = attacher.call(processor, ...options)\n\n      if (typeof transformer === 'function') {\n        transformers.use(transformer)\n      }\n    }\n\n    frozen = true\n    freezeIndex = Number.POSITIVE_INFINITY\n\n    return processor\n  }\n\n  /**\n   * @param {Pluggable|null|undefined} [value]\n   * @param {...unknown} options\n   * @returns {Processor}\n   */\n  function use(value, ...options) {\n    /** @type {Record<string, unknown>|undefined} */\n    let settings\n\n    assertUnfrozen('use', frozen)\n\n    if (value === null || value === undefined) {\n      // Empty.\n    } else if (typeof value === 'function') {\n      addPlugin(value, ...options)\n    } else if (typeof value === 'object') {\n      if (Array.isArray(value)) {\n        addList(value)\n      } else {\n        addPreset(value)\n      }\n    } else {\n      throw new TypeError('Expected usable value, not `' + value + '`')\n    }\n\n    if (settings) {\n      namespace.settings = Object.assign(namespace.settings || {}, settings)\n    }\n\n    return processor\n\n    /**\n     * @param {import('..').Pluggable<unknown[]>} value\n     * @returns {void}\n     */\n    function add(value) {\n      if (typeof value === 'function') {\n        addPlugin(value)\n      } else if (typeof value === 'object') {\n        if (Array.isArray(value)) {\n          const [plugin, ...options] = value\n          addPlugin(plugin, ...options)\n        } else {\n          addPreset(value)\n        }\n      } else {\n        throw new TypeError('Expected usable value, not `' + value + '`')\n      }\n    }\n\n    /**\n     * @param {Preset} result\n     * @returns {void}\n     */\n    function addPreset(result) {\n      addList(result.plugins)\n\n      if (result.settings) {\n        settings = Object.assign(settings || {}, result.settings)\n      }\n    }\n\n    /**\n     * @param {PluggableList|null|undefined} [plugins]\n     * @returns {void}\n     */\n    function addList(plugins) {\n      let index = -1\n\n      if (plugins === null || plugins === undefined) {\n        // Empty.\n      } else if (Array.isArray(plugins)) {\n        while (++index < plugins.length) {\n          const thing = plugins[index]\n          add(thing)\n        }\n      } else {\n        throw new TypeError('Expected a list of plugins, not `' + plugins + '`')\n      }\n    }\n\n    /**\n     * @param {Plugin} plugin\n     * @param {...unknown} [value]\n     * @returns {void}\n     */\n    function addPlugin(plugin, value) {\n      let index = -1\n      /** @type {Processor['attachers'][number]|undefined} */\n      let entry\n\n      while (++index < attachers.length) {\n        if (attachers[index][0] === plugin) {\n          entry = attachers[index]\n          break\n        }\n      }\n\n      if (entry) {\n        if (isPlainObj(entry[1]) && isPlainObj(value)) {\n          value = extend(true, entry[1], value)\n        }\n\n        entry[1] = value\n      } else {\n        // @ts-expect-error: fine.\n        attachers.push([...arguments])\n      }\n    }\n  }\n\n  /** @type {Processor['parse']} */\n  function parse(doc) {\n    processor.freeze()\n    const file = vfile(doc)\n    const Parser = processor.Parser\n    assertParser('parse', Parser)\n\n    if (newable(Parser, 'parse')) {\n      // @ts-expect-error: `newable` checks this.\n      return new Parser(String(file), file).parse()\n    }\n\n    // @ts-expect-error: `newable` checks this.\n    return Parser(String(file), file) // eslint-disable-line new-cap\n  }\n\n  /** @type {Processor['stringify']} */\n  function stringify(node, doc) {\n    processor.freeze()\n    const file = vfile(doc)\n    const Compiler = processor.Compiler\n    assertCompiler('stringify', Compiler)\n    assertNode(node)\n\n    if (newable(Compiler, 'compile')) {\n      // @ts-expect-error: `newable` checks this.\n      return new Compiler(node, file).compile()\n    }\n\n    // @ts-expect-error: `newable` checks this.\n    return Compiler(node, file) // eslint-disable-line new-cap\n  }\n\n  /**\n   * @param {Node} node\n   * @param {VFileCompatible|RunCallback} [doc]\n   * @param {RunCallback} [callback]\n   * @returns {Promise<Node>|void}\n   */\n  function run(node, doc, callback) {\n    assertNode(node)\n    processor.freeze()\n\n    if (!callback && typeof doc === 'function') {\n      callback = doc\n      doc = undefined\n    }\n\n    if (!callback) {\n      return new Promise(executor)\n    }\n\n    executor(null, callback)\n\n    /**\n     * @param {null|((node: Node) => void)} resolve\n     * @param {(error: Error) => void} reject\n     * @returns {void}\n     */\n    function executor(resolve, reject) {\n      // @ts-expect-error: `doc` can’t be a callback anymore, we checked.\n      transformers.run(node, vfile(doc), done)\n\n      /**\n       * @param {Error|null} error\n       * @param {Node} tree\n       * @param {VFile} file\n       * @returns {void}\n       */\n      function done(error, tree, file) {\n        tree = tree || node\n        if (error) {\n          reject(error)\n        } else if (resolve) {\n          resolve(tree)\n        } else {\n          // @ts-expect-error: `callback` is defined if `resolve` is not.\n          callback(null, tree, file)\n        }\n      }\n    }\n  }\n\n  /** @type {Processor['runSync']} */\n  function runSync(node, file) {\n    /** @type {Node|undefined} */\n    let result\n    /** @type {boolean|undefined} */\n    let complete\n\n    processor.run(node, file, done)\n\n    assertDone('runSync', 'run', complete)\n\n    // @ts-expect-error: we either bailed on an error or have a tree.\n    return result\n\n    /**\n     * @param {Error|null} [error]\n     * @param {Node} [tree]\n     * @returns {void}\n     */\n    function done(error, tree) {\n      bail(error)\n      result = tree\n      complete = true\n    }\n  }\n\n  /**\n   * @param {VFileCompatible} doc\n   * @param {ProcessCallback} [callback]\n   * @returns {Promise<VFile>|undefined}\n   */\n  function process(doc, callback) {\n    processor.freeze()\n    assertParser('process', processor.Parser)\n    assertCompiler('process', processor.Compiler)\n\n    if (!callback) {\n      return new Promise(executor)\n    }\n\n    executor(null, callback)\n\n    /**\n     * @param {null|((file: VFile) => void)} resolve\n     * @param {(error?: Error|null|undefined) => void} reject\n     * @returns {void}\n     */\n    function executor(resolve, reject) {\n      const file = vfile(doc)\n\n      processor.run(processor.parse(file), file, (error, tree, file) => {\n        if (error || !tree || !file) {\n          done(error)\n        } else {\n          /** @type {unknown} */\n          const result = processor.stringify(tree, file)\n\n          if (result === undefined || result === null) {\n            // Empty.\n          } else if (looksLikeAVFileValue(result)) {\n            file.value = result\n          } else {\n            file.result = result\n          }\n\n          done(error, file)\n        }\n      })\n\n      /**\n       * @param {Error|null|undefined} [error]\n       * @param {VFile|undefined} [file]\n       * @returns {void}\n       */\n      function done(error, file) {\n        if (error || !file) {\n          reject(error)\n        } else if (resolve) {\n          resolve(file)\n        } else {\n          // @ts-expect-error: `callback` is defined if `resolve` is not.\n          callback(null, file)\n        }\n      }\n    }\n  }\n\n  /** @type {Processor['processSync']} */\n  function processSync(doc) {\n    /** @type {boolean|undefined} */\n    let complete\n\n    processor.freeze()\n    assertParser('processSync', processor.Parser)\n    assertCompiler('processSync', processor.Compiler)\n\n    const file = vfile(doc)\n\n    processor.process(file, done)\n\n    assertDone('processSync', 'process', complete)\n\n    return file\n\n    /**\n     * @param {Error|null|undefined} [error]\n     * @returns {void}\n     */\n    function done(error) {\n      complete = true\n      bail(error)\n    }\n  }\n}\n\n/**\n * Check if `value` is a constructor.\n *\n * @param {unknown} value\n * @param {string} name\n * @returns {boolean}\n */\nfunction newable(value, name) {\n  return (\n    typeof value === 'function' &&\n    // Prototypes do exist.\n    // type-coverage:ignore-next-line\n    value.prototype &&\n    // A function with keys in its prototype is probably a constructor.\n    // Classes’ prototype methods are not enumerable, so we check if some value\n    // exists in the prototype.\n    // type-coverage:ignore-next-line\n    (keys(value.prototype) || name in value.prototype)\n  )\n}\n\n/**\n * Check if `value` is an object with keys.\n *\n * @param {Record<string, unknown>} value\n * @returns {boolean}\n */\nfunction keys(value) {\n  /** @type {string} */\n  let key\n\n  for (key in value) {\n    if (own.call(value, key)) {\n      return true\n    }\n  }\n\n  return false\n}\n\n/**\n * Assert a parser is available.\n *\n * @param {string} name\n * @param {unknown} value\n * @returns {asserts value is Parser}\n */\nfunction assertParser(name, value) {\n  if (typeof value !== 'function') {\n    throw new TypeError('Cannot `' + name + '` without `Parser`')\n  }\n}\n\n/**\n * Assert a compiler is available.\n *\n * @param {string} name\n * @param {unknown} value\n * @returns {asserts value is Compiler}\n */\nfunction assertCompiler(name, value) {\n  if (typeof value !== 'function') {\n    throw new TypeError('Cannot `' + name + '` without `Compiler`')\n  }\n}\n\n/**\n * Assert the processor is not frozen.\n *\n * @param {string} name\n * @param {unknown} frozen\n * @returns {asserts frozen is false}\n */\nfunction assertUnfrozen(name, frozen) {\n  if (frozen) {\n    throw new Error(\n      'Cannot call `' +\n        name +\n        '` on a frozen processor.\\nCreate a new processor first, by calling it: use `processor()` instead of `processor`.'\n    )\n  }\n}\n\n/**\n * Assert `node` is a unist node.\n *\n * @param {unknown} node\n * @returns {asserts node is Node}\n */\nfunction assertNode(node) {\n  // `isPlainObj` unfortunately uses `any` instead of `unknown`.\n  // type-coverage:ignore-next-line\n  if (!isPlainObj(node) || typeof node.type !== 'string') {\n    throw new TypeError('Expected node, got `' + node + '`')\n    // Fine.\n  }\n}\n\n/**\n * Assert that `complete` is `true`.\n *\n * @param {string} name\n * @param {string} asyncName\n * @param {unknown} complete\n * @returns {asserts complete is true}\n */\nfunction assertDone(name, asyncName, complete) {\n  if (!complete) {\n    throw new Error(\n      '`' + name + '` finished async. Use `' + asyncName + '` instead'\n    )\n  }\n}\n\n/**\n * @param {VFileCompatible} [value]\n * @returns {VFile}\n */\nfunction vfile(value) {\n  return looksLikeAVFile(value) ? value : new VFile(value)\n}\n\n/**\n * @param {VFileCompatible} [value]\n * @returns {value is VFile}\n */\nfunction looksLikeAVFile(value) {\n  return Boolean(\n    value &&\n      typeof value === 'object' &&\n      'message' in value &&\n      'messages' in value\n  )\n}\n\n/**\n * @param {unknown} [value]\n * @returns {value is VFileValue}\n */\nfunction looksLikeAVFileValue(value) {\n  return typeof value === 'string' || isBuffer(value)\n}\n","/**\n * @typedef {import('unist').Node} Node\n * @typedef {import('unist').Point} Point\n * @typedef {import('unist').Position} Position\n */\n\n/**\n * @typedef NodeLike\n * @property {string} type\n * @property {PositionLike | null | undefined} [position]\n *\n * @typedef PositionLike\n * @property {PointLike | null | undefined} [start]\n * @property {PointLike | null | undefined} [end]\n *\n * @typedef PointLike\n * @property {number | null | undefined} [line]\n * @property {number | null | undefined} [column]\n * @property {number | null | undefined} [offset]\n */\n\n/**\n * Serialize the positional info of a point, position (start and end points),\n * or node.\n *\n * @param {Node | NodeLike | Position | PositionLike | Point | PointLike | null | undefined} [value]\n *   Node, position, or point.\n * @returns {string}\n *   Pretty printed positional info of a node (`string`).\n *\n *   In the format of a range `ls:cs-le:ce` (when given `node` or `position`)\n *   or a point `l:c` (when given `point`), where `l` stands for line, `c` for\n *   column, `s` for `start`, and `e` for end.\n *   An empty string (`''`) is returned if the given value is neither `node`,\n *   `position`, nor `point`.\n */\nexport function stringifyPosition(value) {\n  // Nothing.\n  if (!value || typeof value !== 'object') {\n    return ''\n  }\n\n  // Node.\n  if ('position' in value || 'type' in value) {\n    return position(value.position)\n  }\n\n  // Position.\n  if ('start' in value || 'end' in value) {\n    return position(value)\n  }\n\n  // Point.\n  if ('line' in value || 'column' in value) {\n    return point(value)\n  }\n\n  // ?\n  return ''\n}\n\n/**\n * @param {Point | PointLike | null | undefined} point\n * @returns {string}\n */\nfunction point(point) {\n  return index(point && point.line) + ':' + index(point && point.column)\n}\n\n/**\n * @param {Position | PositionLike | null | undefined} pos\n * @returns {string}\n */\nfunction position(pos) {\n  return point(pos && pos.start) + '-' + point(pos && pos.end)\n}\n\n/**\n * @param {number | null | undefined} value\n * @returns {number}\n */\nfunction index(value) {\n  return value && typeof value === 'number' ? value : 1\n}\n"],"names":["hasOwn","Object","prototype","hasOwnProperty","toStr","toString","defineProperty","gOPD","getOwnPropertyDescriptor","isArray","arr","Array","call","isPlainObject","obj","key","hasOwnConstructor","hasIsPrototypeOf","constructor","setProperty","target","options","name","enumerable","configurable","value","newValue","writable","getProperty","module","exports","extend","src","copy","copyIsArray","clone","arguments","i","length","deep","isBuffer","bail","error","getPrototypeOf","Symbol","toStringTag","iterator","trough","fns","pipeline","run","_len","values","_key","middlewareIndex","callback","pop","TypeError","next","fn","index","_len2","output","_key2","undefined","middleware","called","wrapped","_len3","parameters","_key3","fnExpectsCallback","result","push","done","apply","this","then","Error","_len4","_key4","wrap","use","middelware","VFileMessage","reason","place","origin","parts","position","start","line","column","end","super","indexOf","slice","stringifyPosition","message","stack","fatal","source","ruleId","file","actual","expected","url","note","path","basename","ext","assertPath","seenNonSlash","charCodeAt","firstNonSlashEnd","extIndex","dirname","unmatchedSlash","extname","startPart","startDot","preDotState","code","join","joined","segments","absolute","allowAboveRoot","lastSlashIndex","lastSegmentLength","lastSlash","dots","lastIndexOf","normalizeString","normalize","sep","JSON","stringify","proc","cwd","isUrl","fileUrlOrPath","href","urlToPath","URL","protocol","hostname","pathname","third","decodeURIComponent","getPathFromURLPosix","order","VFile","bufferLike","buffer","data","messages","history","stored","map","prop","includes","assertNonEmpty","assertPart","stem","encoding","info","fail","part","unified","base","transformers","attachers","frozen","namespace","freezeIndex","processor","assertUnfrozen","own","Parser","Compiler","freeze","attacher","transformer","Number","POSITIVE_INFINITY","settings","addPlugin","addList","addPreset","assign","add","plugin","plugins","entry","isPlainObj","parse","doc","vfile","assertParser","newable","String","node","assertCompiler","assertNode","compile","Promise","executor","resolve","reject","tree","runSync","complete","assertDone","process","processSync","destination","keys","type","asyncName","Boolean","looksLikeAVFile","point","pos"],"sourceRoot":""}